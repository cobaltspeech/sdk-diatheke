// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: diatheke.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (2019) Cobalt Speech and Language Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The message sent by the server for the `Version` method.
public struct Cobaltspeech_Diatheke_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server that manages all of the the other components.
  public var server: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message sent by the server in response to a Models request.
/// Returns an array of model names.
public struct Cobaltspeech_Diatheke_ModelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Array of models available for use.
  public var models: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for the NewSession call.
/// TODO: Consider combining the language and model into one string, such as `en_US_variant`.
public struct Cobaltspeech_Diatheke_NewSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For applications that have more than one model to use for ASR/NLU.
  /// ASR grammar can vary between models, as well as sets of commands.
  /// Some applications will only have one model.
  public var model: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Simple message that only contains the session ID.
public struct Cobaltspeech_Diatheke_SessionID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Session ID returned from the NewSession call.
  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An event from Diatheke in response to either recognized audio or
/// submitted text.
public struct Cobaltspeech_Diatheke_DiathekeEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Cobaltspeech_Diatheke_DiathekeEvent.OneOf_Result? = nil

  /// Indicates Diatheke found an actionable state in the dialog,
  /// and requests the client to perform the given command.
  ///
  /// While not strictly required (depeding on the model and command),
  /// it is best practice to always call CommandFinished after receiving
  /// this event so that Diatheke can update the dialog state when the
  /// command is complete. Cases where it is required include when the
  /// command has output parameters, or when it is followed by another
  /// action in the Diatheke model.
  public var command: Cobaltspeech_Diatheke_CommandEvent {
    get {
      if case .command(let v)? = result {return v}
      return Cobaltspeech_Diatheke_CommandEvent()
    }
    set {result = .command(newValue)}
  }

  /// An event indicating whether pushed text and audio was recognized by
  /// ASR and/or Diatheke.
  public var recognize: Cobaltspeech_Diatheke_RecognizeEvent {
    get {
      if case .recognize(let v)? = result {return v}
      return Cobaltspeech_Diatheke_RecognizeEvent()
    }
    set {result = .recognize(newValue)}
  }

  /// The textual reply from Diatheke in the conversation (not to be 
  /// confused with the server concepts of request and response). For 
  /// example, this could be a question to solicit more information 
  /// from the user, a status report, or any other reply defined by 
  /// the Diatheke model. The text of this message is also provided in
  /// the AudioReply stream (if one is open).
  public var reply: Cobaltspeech_Diatheke_ReplyEvent {
    get {
      if case .reply(let v)? = result {return v}
      return Cobaltspeech_Diatheke_ReplyEvent()
    }
    set {result = .reply(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    /// Indicates Diatheke found an actionable state in the dialog,
    /// and requests the client to perform the given command.
    ///
    /// While not strictly required (depeding on the model and command),
    /// it is best practice to always call CommandFinished after receiving
    /// this event so that Diatheke can update the dialog state when the
    /// command is complete. Cases where it is required include when the
    /// command has output parameters, or when it is followed by another
    /// action in the Diatheke model.
    case command(Cobaltspeech_Diatheke_CommandEvent)
    /// An event indicating whether pushed text and audio was recognized by
    /// ASR and/or Diatheke.
    case recognize(Cobaltspeech_Diatheke_RecognizeEvent)
    /// The textual reply from Diatheke in the conversation (not to be 
    /// confused with the server concepts of request and response). For 
    /// example, this could be a question to solicit more information 
    /// from the user, a status report, or any other reply defined by 
    /// the Diatheke model. The text of this message is also provided in
    /// the AudioReply stream (if one is open).
    case reply(Cobaltspeech_Diatheke_ReplyEvent)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_DiathekeEvent.OneOf_Result, rhs: Cobaltspeech_Diatheke_DiathekeEvent.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.command(let l), .command(let r)): return l == r
      case (.recognize(let l), .recognize(let r)): return l == r
      case (.reply(let l), .reply(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A CommandEvent occurs when Diatheke wants the client to execute the
/// given command.
public struct Cobaltspeech_Diatheke_CommandEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the command that should be run.  i.e. "COM01" for Command #01.
  public var commandID: String = String()

  /// A generic map of parameters (name, value). The parameters are 
  /// defined in the Diatheke model. Depending on the command, these
  /// parameters should be sent back with the CommandStatus update.
  public var parameters: Dictionary<String,String> = [:]

  /// ID to keep track of the dialog state when the command is requested.
  /// This field is required in the CommandStatus message so that Diatheke
  /// can correctly update the dialog state when CommandFinished is called.
  public var commandStateID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A RecognizeEvent occurs if a session's audio input has a transcription
/// available, or if the PushText method was called. In both cases, the
/// event will indicate whether the text was recognized as a valid intent
/// by the Diatheke model.
public struct Cobaltspeech_Diatheke_RecognizeEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The pushed text or transcription of audio sent to Diatheke.
  public var text: String = String()

  /// True if the submitted text or audio transcription was recognized by the
  /// Diatheke model as a valid intent or entity.
  public var validInput: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A ReplyEvent occurs when Diatheke has a reply in the conversation (not
/// to be confused with the server concepts of request and response). These
/// correspond to "say" entries in the Diatheke model. For example, it might
/// be a prompt for additional information from the user, a status update,
/// or a confirmation. ReplyEvents are not generated in response to 
/// StreamTTS calls.
public struct Cobaltspeech_Diatheke_ReplyEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text of the reply event (defined by the Diatheke model).
  public var text: String = String()

  /// Label of the reply event (defined by the Diatheke model).
  public var label: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The final status of an executed command.
public struct Cobaltspeech_Diatheke_CommandStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session_id should be the same as the status id returned from
  /// NewSessionResponse.
  public var sessionID: String = String()

  /// ID of the command as given in the RunCommand object.
  public var commandID: String = String()

  public var returnStatus: Cobaltspeech_Diatheke_CommandStatus.StatusCode = .success

  /// The populated output parameters from the RunCommand object. For example,
  /// the map might contain the entry "temperature", which was populated with
  /// a value of "30" after the command finished.
  public var outputParameters: Dictionary<String,String> = [:]

  /// Set this field with an error message if an a error occured while
  /// executing the command.
  public var errorMessageText: String = String()

  /// State ID from the original CommandEvent. This field is required for
  /// Diatheke to correctly update the dialog state when CommandFinished 
  /// is called.
  public var commandStateID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// CommandStatus are the resulting states of a command.
  public enum StatusCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// SUCCESS indicates that the command was successfully completed, and the
    /// dialog state may now move on to the next state.
    case success // = 0

    /// FAILURE indicates that the command was not successfully completed, and
    /// the dialog state should be updated accordingly.
    case failure // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .failure: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Cobaltspeech_Diatheke_CommandStatus.StatusCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cobaltspeech_Diatheke_CommandStatus.StatusCode] = [
    .success,
    .failure,
  ]
}

#endif  // swift(>=4.2)

/// Provides input audio data for StreamAudioInput. The first message
/// sent must contain the session ID only. All subsequent messages
/// must contain audio data only.
public struct Cobaltspeech_Diatheke_AudioInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Cobaltspeech_Diatheke_AudioInput.OneOf_Request? = nil

  /// Session ID returned from the NewSession call.
  public var sessionID: String {
    get {
      if case .sessionID(let v)? = request {return v}
      return String()
    }
    set {request = .sessionID(newValue)}
  }

  /// Audio data to process. The encoding of the data should match what
  /// was specified in the Diatheke server configuration.
  /// NOTE: If the audio data is empty, the server may interpret it as
  ///       the end of the stream and stop accepting further messages.
  public var data: Data {
    get {
      if case .data(let v)? = request {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {request = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    /// Session ID returned from the NewSession call.
    case sessionID(String)
    /// Audio data to process. The encoding of the data should match what
    /// was specified in the Diatheke server configuration.
    /// NOTE: If the audio data is empty, the server may interpret it as
    ///       the end of the stream and stop accepting further messages.
    case data(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_AudioInput.OneOf_Request, rhs: Cobaltspeech_Diatheke_AudioInput.OneOf_Request) -> Bool {
      switch (lhs, rhs) {
      case (.sessionID(let l), .sessionID(let r)): return l == r
      case (.data(let l), .data(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// An AudioReply is the verbal and textual reply that Diatheke returns as
/// part of a conversation (not to be confused with the server concepts of
/// request and response).
public struct Cobaltspeech_Diatheke_AudioReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The label defined in the Diatheke model. Identifies which "say" entry
  /// in the model this message corresponds to.
  public var label: String = String()

  public var outputMessage: Cobaltspeech_Diatheke_AudioReply.OneOf_OutputMessage? = nil

  /// The reply text as defined in the Diatheke model. This is the first
  /// message that will be received for an AudioReply. It contains the
  /// same text as the corresponding ReplyEvent in the session's event
  /// stream.
  public var text: String {
    get {
      if case .text(let v)? = outputMessage {return v}
      return String()
    }
    set {outputMessage = .text(newValue)}
  }

  /// The audio data from TTS. There can be any number of these messages
  /// for an AudioReply after the first text message and before the final
  /// end message. The encoding of the data will match what was specified
  /// in the server configuration.
  public var data: Data {
    get {
      if case .data(let v)? = outputMessage {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {outputMessage = .data(newValue)}
  }

  /// Indicates that TTS has finished streaming audio for the reply. This
  /// is the last message that will be received for an AudioReply.
  public var end: Cobaltspeech_Diatheke_Empty {
    get {
      if case .end(let v)? = outputMessage {return v}
      return Cobaltspeech_Diatheke_Empty()
    }
    set {outputMessage = .end(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_OutputMessage: Equatable {
    /// The reply text as defined in the Diatheke model. This is the first
    /// message that will be received for an AudioReply. It contains the
    /// same text as the corresponding ReplyEvent in the session's event
    /// stream.
    case text(String)
    /// The audio data from TTS. There can be any number of these messages
    /// for an AudioReply after the first text message and before the final
    /// end message. The encoding of the data will match what was specified
    /// in the server configuration.
    case data(Data)
    /// Indicates that TTS has finished streaming audio for the reply. This
    /// is the last message that will be received for an AudioReply.
    case end(Cobaltspeech_Diatheke_Empty)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_AudioReply.OneOf_OutputMessage, rhs: Cobaltspeech_Diatheke_AudioReply.OneOf_OutputMessage) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      case (.data(let l), .data(let r)): return l == r
      case (.end(let l), .end(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Request to push text to Diatheke as part of a conversation.
public struct Cobaltspeech_Diatheke_PushTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Session ID returned from the NewSession call.
  public var sessionID: String = String()

  /// User input. This could be a transcription from manually run ASR,
  /// text selected from a dropdown list, entered in a prompt, etc.
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for streaming ASR unrelated to a session.
public struct Cobaltspeech_Diatheke_ASRRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var asrData: Cobaltspeech_Diatheke_ASRRequest.OneOf_AsrData? = nil

  /// The model to use for ASR. This message should always be sent
  /// before any audio data is sent.
  public var model: String {
    get {
      if case .model(let v)? = asrData {return v}
      return String()
    }
    set {asrData = .model(newValue)}
  }

  /// Audio data to process. The encoding of the data should match what
  /// was specified in the Diatheke server configuration.
  /// NOTE: If the audio data is empty, the server may interpret it as
  ///       the end of the stream and stop accepting further messages.
  public var audio: Data {
    get {
      if case .audio(let v)? = asrData {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {asrData = .audio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_AsrData: Equatable {
    /// The model to use for ASR. This message should always be sent
    /// before any audio data is sent.
    case model(String)
    /// Audio data to process. The encoding of the data should match what
    /// was specified in the Diatheke server configuration.
    /// NOTE: If the audio data is empty, the server may interpret it as
    ///       the end of the stream and stop accepting further messages.
    case audio(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_ASRRequest.OneOf_AsrData, rhs: Cobaltspeech_Diatheke_ASRRequest.OneOf_AsrData) -> Bool {
      switch (lhs, rhs) {
      case (.model(let l), .model(let r)): return l == r
      case (.audio(let l), .audio(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// ASRResponse contains speech recognition results.
public struct Cobaltspeech_Diatheke_ASRResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text is the Cubic engine's formatted transcript of pushed audio.
  /// This field will be the 1-best alternative.
  public var text: String = String()

  /// The confidence score is a floating point number between 0.0 - 1.0. A
  /// score of 1.0 indicates that the ASR engine is 100% confident in the
  /// transcription.
  public var confidenceScore: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to synthesize speech unrelated to a session.
public struct Cobaltspeech_Diatheke_TTSRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The model to use for TTS (defined in the server config file).
  public var model: String = String()

  /// Text to synthesize
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for text-to-speech unrelated to a session.
public struct Cobaltspeech_Diatheke_TTSResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The synthesized audio data. The data encoding will match what was
  /// specified in the server configuration.
  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cobaltspeech_Diatheke_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cobaltspeech.diatheke"

extension Cobaltspeech_Diatheke_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "server"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.server)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.server.isEmpty {
      try visitor.visitSingularStringField(value: self.server, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_VersionResponse, rhs: Cobaltspeech_Diatheke_VersionResponse) -> Bool {
    if lhs.server != rhs.server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ModelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "models"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.models)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitRepeatedStringField(value: self.models, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ModelsResponse, rhs: Cobaltspeech_Diatheke_ModelsResponse) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_NewSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewSessionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.model)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_NewSessionRequest, rhs: Cobaltspeech_Diatheke_NewSessionRequest) -> Bool {
    if lhs.model != rhs.model {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SessionID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sessionID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SessionID, rhs: Cobaltspeech_Diatheke_SessionID) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_DiathekeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiathekeEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "recognize"),
    3: .same(proto: "reply"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Cobaltspeech_Diatheke_CommandEvent?
        if let current = self.result {
          try decoder.handleConflictingOneOf()
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.result = .command(v)}
      case 2:
        var v: Cobaltspeech_Diatheke_RecognizeEvent?
        if let current = self.result {
          try decoder.handleConflictingOneOf()
          if case .recognize(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.result = .recognize(v)}
      case 3:
        var v: Cobaltspeech_Diatheke_ReplyEvent?
        if let current = self.result {
          try decoder.handleConflictingOneOf()
          if case .reply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.result = .reply(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.result {
    case .command(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .recognize(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .reply(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_DiathekeEvent, rhs: Cobaltspeech_Diatheke_DiathekeEvent) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_CommandEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .same(proto: "parameters"),
    3: .standard(proto: "command_state_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.commandID)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters)
      case 3: try decoder.decodeSingularStringField(value: &self.commandStateID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commandID.isEmpty {
      try visitor.visitSingularStringField(value: self.commandID, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 2)
    }
    if !self.commandStateID.isEmpty {
      try visitor.visitSingularStringField(value: self.commandStateID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_CommandEvent, rhs: Cobaltspeech_Diatheke_CommandEvent) -> Bool {
    if lhs.commandID != rhs.commandID {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.commandStateID != rhs.commandStateID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_RecognizeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognizeEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "valid_input"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.text)
      case 2: try decoder.decodeSingularBoolField(value: &self.validInput)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.validInput != false {
      try visitor.visitSingularBoolField(value: self.validInput, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_RecognizeEvent, rhs: Cobaltspeech_Diatheke_RecognizeEvent) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.validInput != rhs.validInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ReplyEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplyEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.text)
      case 2: try decoder.decodeSingularStringField(value: &self.label)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ReplyEvent, rhs: Cobaltspeech_Diatheke_ReplyEvent) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_CommandStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "command_id"),
    3: .standard(proto: "return_status"),
    4: .standard(proto: "output_parameters"),
    5: .standard(proto: "error_message_text"),
    6: .standard(proto: "command_state_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sessionID)
      case 2: try decoder.decodeSingularStringField(value: &self.commandID)
      case 3: try decoder.decodeSingularEnumField(value: &self.returnStatus)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.outputParameters)
      case 5: try decoder.decodeSingularStringField(value: &self.errorMessageText)
      case 6: try decoder.decodeSingularStringField(value: &self.commandStateID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.commandID.isEmpty {
      try visitor.visitSingularStringField(value: self.commandID, fieldNumber: 2)
    }
    if self.returnStatus != .success {
      try visitor.visitSingularEnumField(value: self.returnStatus, fieldNumber: 3)
    }
    if !self.outputParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.outputParameters, fieldNumber: 4)
    }
    if !self.errorMessageText.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessageText, fieldNumber: 5)
    }
    if !self.commandStateID.isEmpty {
      try visitor.visitSingularStringField(value: self.commandStateID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_CommandStatus, rhs: Cobaltspeech_Diatheke_CommandStatus) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.returnStatus != rhs.returnStatus {return false}
    if lhs.outputParameters != rhs.outputParameters {return false}
    if lhs.errorMessageText != rhs.errorMessageText {return false}
    if lhs.commandStateID != rhs.commandStateID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_CommandStatus.StatusCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "FAILURE"),
  ]
}

extension Cobaltspeech_Diatheke_AudioInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.request != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.request = .sessionID(v)}
      case 2:
        if self.request != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.request = .data(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.request {
    case .sessionID(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .data(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_AudioInput, rhs: Cobaltspeech_Diatheke_AudioInput) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_AudioReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "text"),
    3: .same(proto: "data"),
    4: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      case 2:
        if self.outputMessage != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.outputMessage = .text(v)}
      case 3:
        if self.outputMessage != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.outputMessage = .data(v)}
      case 4:
        var v: Cobaltspeech_Diatheke_Empty?
        if let current = self.outputMessage {
          try decoder.handleConflictingOneOf()
          if case .end(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.outputMessage = .end(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    switch self.outputMessage {
    case .text(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .data(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case .end(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_AudioReply, rhs: Cobaltspeech_Diatheke_AudioReply) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.outputMessage != rhs.outputMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_PushTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushTextRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sessionID)
      case 2: try decoder.decodeSingularStringField(value: &self.text)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_PushTextRequest, rhs: Cobaltspeech_Diatheke_PushTextRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ASRRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ASRRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.asrData != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.asrData = .model(v)}
      case 2:
        if self.asrData != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.asrData = .audio(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.asrData {
    case .model(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .audio(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ASRRequest, rhs: Cobaltspeech_Diatheke_ASRRequest) -> Bool {
    if lhs.asrData != rhs.asrData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ASRResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ASRResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "confidence_score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.text)
      case 2: try decoder.decodeSingularDoubleField(value: &self.confidenceScore)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.confidenceScore != 0 {
      try visitor.visitSingularDoubleField(value: self.confidenceScore, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ASRResponse, rhs: Cobaltspeech_Diatheke_ASRResponse) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.confidenceScore != rhs.confidenceScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TTSRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTSRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.model)
      case 2: try decoder.decodeSingularStringField(value: &self.text)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TTSRequest, rhs: Cobaltspeech_Diatheke_TTSRequest) -> Bool {
    if lhs.model != rhs.model {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TTSResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTSResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TTSResponse, rhs: Cobaltspeech_Diatheke_TTSResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_Empty, rhs: Cobaltspeech_Diatheke_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
