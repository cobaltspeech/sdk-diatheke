// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: diatheke.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (2021) Cobalt Speech and Language Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Lists the version of Diatheke and the engines it uses.
public struct Cobaltspeech_Diatheke_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Dialog management engine
  public var diatheke: String = String()

  /// NLU engine
  public var chosun: String = String()

  /// ASR engine
  public var cubic: String = String()

  /// TTS engine
  public var luna: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A list of models available on the Diatheke server.
public struct Cobaltspeech_Diatheke_ListModelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var models: [Cobaltspeech_Diatheke_ModelInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Information about a single Diatheke model.
public struct Cobaltspeech_Diatheke_ModelInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Diatheke model ID, which is used to create a new session.
  public var id: String = String()

  /// Pretty model name, which may be used for display purposes.
  public var name: String = String()

  /// Language code of the model.
  public var language: String = String()

  /// The ASR audio sample rate, if ASR is enabled.
  public var asrSampleRate: UInt32 = 0

  /// The TTS audio sample rate, if TTS is enabled.
  public var ttsSampleRate: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used by Diatheke to update the session state.
public struct Cobaltspeech_Diatheke_SessionInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The session token.
  public var token: Cobaltspeech_Diatheke_TokenData {
    get {return _token ?? Cobaltspeech_Diatheke_TokenData()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var input: Cobaltspeech_Diatheke_SessionInput.OneOf_Input? = nil

  /// Process the user supplied text.
  public var text: Cobaltspeech_Diatheke_TextInput {
    get {
      if case .text(let v)? = input {return v}
      return Cobaltspeech_Diatheke_TextInput()
    }
    set {input = .text(newValue)}
  }

  /// Process an ASR result.
  public var asr: Cobaltspeech_Diatheke_ASRResult {
    get {
      if case .asr(let v)? = input {return v}
      return Cobaltspeech_Diatheke_ASRResult()
    }
    set {input = .asr(newValue)}
  }

  /// Process the result of a completed command.
  public var cmd: Cobaltspeech_Diatheke_CommandResult {
    get {
      if case .cmd(let v)? = input {return v}
      return Cobaltspeech_Diatheke_CommandResult()
    }
    set {input = .cmd(newValue)}
  }

  /// Change the current session state.
  public var story: Cobaltspeech_Diatheke_SetStory {
    get {
      if case .story(let v)? = input {return v}
      return Cobaltspeech_Diatheke_SetStory()
    }
    set {input = .story(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Input: Equatable {
    /// Process the user supplied text.
    case text(Cobaltspeech_Diatheke_TextInput)
    /// Process an ASR result.
    case asr(Cobaltspeech_Diatheke_ASRResult)
    /// Process the result of a completed command.
    case cmd(Cobaltspeech_Diatheke_CommandResult)
    /// Change the current session state.
    case story(Cobaltspeech_Diatheke_SetStory)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_SessionInput.OneOf_Input, rhs: Cobaltspeech_Diatheke_SessionInput.OneOf_Input) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.asr, .asr): return {
        guard case .asr(let l) = lhs, case .asr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cmd, .cmd): return {
        guard case .cmd(let l) = lhs, case .cmd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.story, .story): return {
        guard case .story(let l) = lhs, case .story(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _token: Cobaltspeech_Diatheke_TokenData? = nil
}

/// A token that represents a single Diatheke session and its
/// current state.
public struct Cobaltspeech_Diatheke_TokenData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  /// Session ID, useful for correlating logging between a
  /// client and the server.
  public var id: String = String()

  /// Additional data supplied by the client app, which will
  /// be logged with other session info by the server.
  public var metadata: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to create a new session.
public struct Cobaltspeech_Diatheke_SessionStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the Diatheke model ID to use for the session.
  public var modelID: String = String()

  /// Specifies a custom wakeword to use for this session. The
  /// wakeword must be enabled in the Diatheke model for this
  /// to have any effect. It will override the default wakeword
  /// specified in the model.
  public var wakeword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// User supplied text to send to Diatheke for processing.
public struct Cobaltspeech_Diatheke_TextInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The result of executing a command.
public struct Cobaltspeech_Diatheke_CommandResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The command ID, as given by the CommandAction
  public var id: String = String()

  /// Output from the command expected by the Diatheke model.
  /// For example, this could be the result of a data query.
  public var outParameters: Dictionary<String,String> = [:]

  /// If there was an error during execution, indicate it
  /// here with a brief message that will be logged by
  /// Diatheke.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Changes the current state of a Diatheke session to run at
/// the specified story.
public struct Cobaltspeech_Diatheke_SetStory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the story to run, as defined in the
  /// Diatheke model.
  public var storyID: String = String()

  /// A list of parameters to set before running the given
  /// story. This will replace any parameters currently
  /// defined in the session.
  public var parameters: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The result of updating a session.
public struct Cobaltspeech_Diatheke_SessionOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The updated session token.
  public var token: Cobaltspeech_Diatheke_TokenData {
    get {return _token ?? Cobaltspeech_Diatheke_TokenData()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// The list of actions the client should take next,
  /// using the session token returned with this result.
  public var actionList: [Cobaltspeech_Diatheke_ActionData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Cobaltspeech_Diatheke_TokenData? = nil
}

/// Specifies an action that the client application should take.
public struct Cobaltspeech_Diatheke_ActionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Cobaltspeech_Diatheke_ActionData.OneOf_Action? = nil

  /// The user must provide input to Diatheke.
  public var input: Cobaltspeech_Diatheke_WaitForUserAction {
    get {
      if case .input(let v)? = action {return v}
      return Cobaltspeech_Diatheke_WaitForUserAction()
    }
    set {action = .input(newValue)}
  }

  /// The client app must execute the specified command.
  public var command: Cobaltspeech_Diatheke_CommandAction {
    get {
      if case .command(let v)? = action {return v}
      return Cobaltspeech_Diatheke_CommandAction()
    }
    set {action = .command(newValue)}
  }

  /// The client app should provide the reply to the user.
  public var reply: Cobaltspeech_Diatheke_ReplyAction {
    get {
      if case .reply(let v)? = action {return v}
      return Cobaltspeech_Diatheke_ReplyAction()
    }
    set {action = .reply(newValue)}
  }

  /// The client app should transcribe user input.
  public var transcribe: Cobaltspeech_Diatheke_TranscribeAction {
    get {
      if case .transcribe(let v)? = action {return v}
      return Cobaltspeech_Diatheke_TranscribeAction()
    }
    set {action = .transcribe(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    /// The user must provide input to Diatheke.
    case input(Cobaltspeech_Diatheke_WaitForUserAction)
    /// The client app must execute the specified command.
    case command(Cobaltspeech_Diatheke_CommandAction)
    /// The client app should provide the reply to the user.
    case reply(Cobaltspeech_Diatheke_ReplyAction)
    /// The client app should transcribe user input.
    case transcribe(Cobaltspeech_Diatheke_TranscribeAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_ActionData.OneOf_Action, rhs: Cobaltspeech_Diatheke_ActionData.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.input, .input): return {
        guard case .input(let l) = lhs, case .input(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.command, .command): return {
        guard case .command(let l) = lhs, case .command(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reply, .reply): return {
        guard case .reply(let l) = lhs, case .reply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transcribe, .transcribe): return {
        guard case .transcribe(let l) = lhs, case .transcribe(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// This action indicates that Diatheke is expecting user input.
public struct Cobaltspeech_Diatheke_WaitForUserAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if the next user input must begin with a wake-word.
  public var requiresWakeWord: Bool = false

  /// True if the input is required immediately (i.e., in
  /// response to a question Diatheke asked the user). When
  /// false, the client should be allowed to wait indefinitely
  /// for the user to provide input.
  public var immediate: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This action indicates that the client application should
/// execute a command.
public struct Cobaltspeech_Diatheke_CommandAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the command to execute, as defined in the
  /// Diatheke model.
  public var id: String = String()

  public var inputParameters: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This action indicates that the client application should
/// give the provided text to the user. This action may also 
/// be used to synthesize speech with the StreamTTS method.
public struct Cobaltspeech_Diatheke_ReplyAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text of the reply
  public var text: String = String()

  /// TTS model to use with the TTSReply method
  public var lunaModel: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This action indicates that the client application should
/// transcribe the user's input.
public struct Cobaltspeech_Diatheke_TranscribeAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the transcribe action, which is useful to
  /// differentiate separate transcription tasks within a
  /// single sesssion.
  public var id: String = String()

  /// The ASR model to use for transcription.
  public var cubicModelID: String = String()

  /// The Diatheke model where this transcribe action is
  /// defined. If empty, the server will not be able to
  /// automatically close the transcribe stream based on
  /// conditions defined in the Diatheke model, such as
  /// a non-speech timeout or an "end-transcription" intent.
  /// When empty, the stream must be closed by the client
  /// application.
  public var diathekeModelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Data to send to the ASR stream. The first message on the
/// stream must be the session token followed by audio data.
public struct Cobaltspeech_Diatheke_ASRInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Cobaltspeech_Diatheke_ASRInput.OneOf_Data? = nil

  /// Session data, used to determine the correct Cubic
  /// model to use for ASR, with other contextual
  /// information.
  public var token: Cobaltspeech_Diatheke_TokenData {
    get {
      if case .token(let v)? = data {return v}
      return Cobaltspeech_Diatheke_TokenData()
    }
    set {data = .token(newValue)}
  }

  /// Audio data to transcribe.
  public var audio: Data {
    get {
      if case .audio(let v)? = data {return v}
      return Data()
    }
    set {data = .audio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    /// Session data, used to determine the correct Cubic
    /// model to use for ASR, with other contextual
    /// information.
    case token(Cobaltspeech_Diatheke_TokenData)
    /// Audio data to transcribe.
    case audio(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_ASRInput.OneOf_Data, rhs: Cobaltspeech_Diatheke_ASRInput.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.token, .token): return {
        guard case .token(let l) = lhs, case .token(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The result from the ASR stream, sent after the ASR engine
/// has endpointed or the stream was closed by the client.
public struct Cobaltspeech_Diatheke_ASRResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transcription.
  public var text: String = String()

  /// Confidence estimate between 0 and 1. A higher number
  /// represents a higher likelihood of the output being 
  /// correct.
  public var confidence: Double = 0

  /// True if a timeout was defined for the session's current
  /// input state in the Diatheke model, and the timeout
  /// expired before getting a transcription. This timeout
  /// refers to the amount of time a user has to verbally
  /// respond to Diatheke after the ASR stream has been
  /// created, and should not be confused with a network
  /// connection timeout.
  public var timedOut: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains synthesized speech audio. The specific encoding
/// is defined in the server config file.
public struct Cobaltspeech_Diatheke_TTSAudio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audio: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Data to send to the Transcribe stream. The first message on
/// the stream must be a TranscribeAction, followed by audio data.
public struct Cobaltspeech_Diatheke_TranscribeInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Cobaltspeech_Diatheke_TranscribeInput.OneOf_Data? = nil

  /// Action defining the transcribe configuration.
  public var action: Cobaltspeech_Diatheke_TranscribeAction {
    get {
      if case .action(let v)? = data {return v}
      return Cobaltspeech_Diatheke_TranscribeAction()
    }
    set {data = .action(newValue)}
  }

  /// Audio data to transcribe.
  public var audio: Data {
    get {
      if case .audio(let v)? = data {return v}
      return Data()
    }
    set {data = .audio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    /// Action defining the transcribe configuration.
    case action(Cobaltspeech_Diatheke_TranscribeAction)
    /// Audio data to transcribe.
    case audio(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_TranscribeInput.OneOf_Data, rhs: Cobaltspeech_Diatheke_TranscribeInput.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.action, .action): return {
        guard case .action(let l) = lhs, case .action(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The result from the Transcribe stream. Usually, many partial
/// (or intermediate) transcriptions will be sent until the final
/// transcription is ready for every utterance processed.
public struct Cobaltspeech_Diatheke_TranscribeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transcription.
  public var text: String = String()

  /// Confidence estimate between 0 and 1. A higher number
  /// represents a higher likelihood of the transcription
  /// being correct.
  public var confidence: Double = 0

  /// True if this is a partial result, in which case the
  /// text of the transcription for the current utterance
  /// being processed is allowed to change in future results.
  /// When false, this represents the final transcription for
  /// an utterance, which will not change with further audio
  /// input. It is sent when the ASR has endpointed. After the
  /// final transcription is sent, any additional results sent
  /// on the Transcribe stream belong to the next utterance.
  public var isPartial: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cobaltspeech_Diatheke_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cobaltspeech.diatheke"

extension Cobaltspeech_Diatheke_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diatheke"),
    2: .same(proto: "chosun"),
    3: .same(proto: "cubic"),
    4: .same(proto: "luna"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.diatheke) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chosun) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cubic) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.luna) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.diatheke.isEmpty {
      try visitor.visitSingularStringField(value: self.diatheke, fieldNumber: 1)
    }
    if !self.chosun.isEmpty {
      try visitor.visitSingularStringField(value: self.chosun, fieldNumber: 2)
    }
    if !self.cubic.isEmpty {
      try visitor.visitSingularStringField(value: self.cubic, fieldNumber: 3)
    }
    if !self.luna.isEmpty {
      try visitor.visitSingularStringField(value: self.luna, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_VersionResponse, rhs: Cobaltspeech_Diatheke_VersionResponse) -> Bool {
    if lhs.diatheke != rhs.diatheke {return false}
    if lhs.chosun != rhs.chosun {return false}
    if lhs.cubic != rhs.cubic {return false}
    if lhs.luna != rhs.luna {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ListModelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "models"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.models) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.models, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ListModelsResponse, rhs: Cobaltspeech_Diatheke_ListModelsResponse) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ModelInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "language"),
    4: .standard(proto: "asr_sample_rate"),
    5: .standard(proto: "tts_sample_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.asrSampleRate) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.ttsSampleRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 3)
    }
    if self.asrSampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.asrSampleRate, fieldNumber: 4)
    }
    if self.ttsSampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttsSampleRate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ModelInfo, rhs: Cobaltspeech_Diatheke_ModelInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.language != rhs.language {return false}
    if lhs.asrSampleRate != rhs.asrSampleRate {return false}
    if lhs.ttsSampleRate != rhs.ttsSampleRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SessionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "text"),
    3: .same(proto: "asr"),
    4: .same(proto: "cmd"),
    5: .same(proto: "story"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try {
        var v: Cobaltspeech_Diatheke_TextInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .text(v)
        }
      }()
      case 3: try {
        var v: Cobaltspeech_Diatheke_ASRResult?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .asr(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .asr(v)
        }
      }()
      case 4: try {
        var v: Cobaltspeech_Diatheke_CommandResult?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .cmd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .cmd(v)
        }
      }()
      case 5: try {
        var v: Cobaltspeech_Diatheke_SetStory?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .story(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .story(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.input {
    case .text?: try {
      guard case .text(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .asr?: try {
      guard case .asr(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .cmd?: try {
      guard case .cmd(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .story?: try {
      guard case .story(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SessionInput, rhs: Cobaltspeech_Diatheke_SessionInput) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "id"),
    3: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TokenData, rhs: Cobaltspeech_Diatheke_TokenData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.id != rhs.id {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SessionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionStart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_id"),
    2: .same(proto: "wakeword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wakeword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 1)
    }
    if !self.wakeword.isEmpty {
      try visitor.visitSingularStringField(value: self.wakeword, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SessionStart, rhs: Cobaltspeech_Diatheke_SessionStart) -> Bool {
    if lhs.modelID != rhs.modelID {return false}
    if lhs.wakeword != rhs.wakeword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TextInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TextInput, rhs: Cobaltspeech_Diatheke_TextInput) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_CommandResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "out_parameters"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.outParameters) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.outParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.outParameters, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_CommandResult, rhs: Cobaltspeech_Diatheke_CommandResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.outParameters != rhs.outParameters {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SetStory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetStory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storyID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storyID.isEmpty {
      try visitor.visitSingularStringField(value: self.storyID, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SetStory, rhs: Cobaltspeech_Diatheke_SetStory) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SessionOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "action_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.actionList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.actionList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SessionOutput, rhs: Cobaltspeech_Diatheke_SessionOutput) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.actionList != rhs.actionList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ActionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "command"),
    3: .same(proto: "reply"),
    4: .same(proto: "transcribe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cobaltspeech_Diatheke_WaitForUserAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .input(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .input(v)
        }
      }()
      case 2: try {
        var v: Cobaltspeech_Diatheke_CommandAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .command(v)
        }
      }()
      case 3: try {
        var v: Cobaltspeech_Diatheke_ReplyAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .reply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .reply(v)
        }
      }()
      case 4: try {
        var v: Cobaltspeech_Diatheke_TranscribeAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .transcribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .transcribe(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.action {
    case .input?: try {
      guard case .input(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .command?: try {
      guard case .command(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .reply?: try {
      guard case .reply(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .transcribe?: try {
      guard case .transcribe(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ActionData, rhs: Cobaltspeech_Diatheke_ActionData) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_WaitForUserAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitForUserAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "requires_wake_word"),
    2: .same(proto: "immediate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.requiresWakeWord) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.immediate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requiresWakeWord != false {
      try visitor.visitSingularBoolField(value: self.requiresWakeWord, fieldNumber: 1)
    }
    if self.immediate != false {
      try visitor.visitSingularBoolField(value: self.immediate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_WaitForUserAction, rhs: Cobaltspeech_Diatheke_WaitForUserAction) -> Bool {
    if lhs.requiresWakeWord != rhs.requiresWakeWord {return false}
    if lhs.immediate != rhs.immediate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_CommandAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "input_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.inputParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.inputParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.inputParameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_CommandAction, rhs: Cobaltspeech_Diatheke_CommandAction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.inputParameters != rhs.inputParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ReplyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplyAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "luna_model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lunaModel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.lunaModel.isEmpty {
      try visitor.visitSingularStringField(value: self.lunaModel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ReplyAction, rhs: Cobaltspeech_Diatheke_ReplyAction) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.lunaModel != rhs.lunaModel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TranscribeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TranscribeAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "cubic_model_id"),
    3: .standard(proto: "diatheke_model_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cubicModelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.diathekeModelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.cubicModelID.isEmpty {
      try visitor.visitSingularStringField(value: self.cubicModelID, fieldNumber: 2)
    }
    if !self.diathekeModelID.isEmpty {
      try visitor.visitSingularStringField(value: self.diathekeModelID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TranscribeAction, rhs: Cobaltspeech_Diatheke_TranscribeAction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.cubicModelID != rhs.cubicModelID {return false}
    if lhs.diathekeModelID != rhs.diathekeModelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ASRInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ASRInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cobaltspeech_Diatheke_TokenData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .token(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .token(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .audio(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.data {
    case .token?: try {
      guard case .token(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ASRInput, rhs: Cobaltspeech_Diatheke_ASRInput) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ASRResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ASRResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "confidence"),
    3: .same(proto: "timedOut"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.confidence) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.timedOut) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 2)
    }
    if self.timedOut != false {
      try visitor.visitSingularBoolField(value: self.timedOut, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ASRResult, rhs: Cobaltspeech_Diatheke_ASRResult) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.timedOut != rhs.timedOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TTSAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTSAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.audio) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audio.isEmpty {
      try visitor.visitSingularBytesField(value: self.audio, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TTSAudio, rhs: Cobaltspeech_Diatheke_TTSAudio) -> Bool {
    if lhs.audio != rhs.audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TranscribeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TranscribeInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cobaltspeech_Diatheke_TranscribeAction?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .action(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .action(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .audio(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.data {
    case .action?: try {
      guard case .action(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TranscribeInput, rhs: Cobaltspeech_Diatheke_TranscribeInput) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TranscribeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TranscribeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "confidence"),
    3: .standard(proto: "is_partial"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.confidence) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isPartial) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 2)
    }
    if self.isPartial != false {
      try visitor.visitSingularBoolField(value: self.isPartial, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TranscribeResult, rhs: Cobaltspeech_Diatheke_TranscribeResult) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.isPartial != rhs.isPartial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_Empty, rhs: Cobaltspeech_Diatheke_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
