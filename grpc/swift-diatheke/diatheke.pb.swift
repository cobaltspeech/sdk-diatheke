// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: diatheke.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (2020) Cobalt Speech and Language Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Lists the version of Diatheke and the engines it uses.
public struct Cobaltspeech_Diatheke_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Dialog management engine
  public var diatheke: String = String()

  /// NLU engine
  public var chosun: String = String()

  /// ASR engine
  public var cubic: String = String()

  /// TTS engine
  public var luna: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A list of models available on the Diatheke server.
public struct Cobaltspeech_Diatheke_ListModelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var models: [Cobaltspeech_Diatheke_ModelInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Information about a single Diatheke model.
public struct Cobaltspeech_Diatheke_ModelInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Diatheke model ID, which is used to create a new session.
  public var id: String = String()

  /// Pretty model name, which may be used for display purposes.
  public var name: String = String()

  /// Language code of the model.
  public var language: String = String()

  /// The ASR audio sample rate, if ASR is enabled.
  public var asrSampleRate: UInt32 = 0

  /// The TTS audio sample rate, if TTS is enabled.
  public var ttsSampleRate: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used by Diatheke to update the session state.
public struct Cobaltspeech_Diatheke_SessionInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The session token.
  public var token: Cobaltspeech_Diatheke_TokenData {
    get {return _token ?? Cobaltspeech_Diatheke_TokenData()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var input: Cobaltspeech_Diatheke_SessionInput.OneOf_Input? = nil

  /// Process the user supplied text.
  public var text: Cobaltspeech_Diatheke_TextInput {
    get {
      if case .text(let v)? = input {return v}
      return Cobaltspeech_Diatheke_TextInput()
    }
    set {input = .text(newValue)}
  }

  /// Process an ASR result.
  public var asr: Cobaltspeech_Diatheke_ASRResult {
    get {
      if case .asr(let v)? = input {return v}
      return Cobaltspeech_Diatheke_ASRResult()
    }
    set {input = .asr(newValue)}
  }

  /// Process the result of a completed command.
  public var cmd: Cobaltspeech_Diatheke_CommandResult {
    get {
      if case .cmd(let v)? = input {return v}
      return Cobaltspeech_Diatheke_CommandResult()
    }
    set {input = .cmd(newValue)}
  }

  /// Change the current session state.
  public var story: Cobaltspeech_Diatheke_SetStory {
    get {
      if case .story(let v)? = input {return v}
      return Cobaltspeech_Diatheke_SetStory()
    }
    set {input = .story(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Input: Equatable {
    /// Process the user supplied text.
    case text(Cobaltspeech_Diatheke_TextInput)
    /// Process an ASR result.
    case asr(Cobaltspeech_Diatheke_ASRResult)
    /// Process the result of a completed command.
    case cmd(Cobaltspeech_Diatheke_CommandResult)
    /// Change the current session state.
    case story(Cobaltspeech_Diatheke_SetStory)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_SessionInput.OneOf_Input, rhs: Cobaltspeech_Diatheke_SessionInput.OneOf_Input) -> Bool {
      switch (lhs, rhs) {
      case (.text(let l), .text(let r)): return l == r
      case (.asr(let l), .asr(let r)): return l == r
      case (.cmd(let l), .cmd(let r)): return l == r
      case (.story(let l), .story(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _token: Cobaltspeech_Diatheke_TokenData? = nil
}

/// A token that represents a single Diatheke session and its
/// current state.
public struct Cobaltspeech_Diatheke_TokenData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = SwiftProtobuf.Internal.emptyData

  /// Session ID, useful for correlating logging between a
  /// client and the server.
  public var id: String = String()

  /// Additional data supplied by the client app, which will
  /// be logged with other session info by the server.
  public var metadata: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to create a new session.
public struct Cobaltspeech_Diatheke_SessionStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the Diatheke model ID to use for the session.
  public var modelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// User supplied text to send to Diatheke for processing.
public struct Cobaltspeech_Diatheke_TextInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The result of executing a command.
public struct Cobaltspeech_Diatheke_CommandResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The command ID, as given by the CommandAction
  public var id: String = String()

  /// Output from the command expected by the Diatheke model.
  /// For example, this could be the result of a data query.
  public var outParameters: Dictionary<String,String> = [:]

  /// If there was an error during execution, indicate it
  /// here with a brief message that will be logged by
  /// Diatheke.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Changes the current state of a Diatheke session to run at
/// the specified story.
public struct Cobaltspeech_Diatheke_SetStory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the story to run, as defined in the
  /// Diatheke model.
  public var storyID: String = String()

  /// A list of parameters to set before running the given
  /// story. This will replace any parameters currently
  /// defined in the session.
  public var parameters: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The result of updating a session.
public struct Cobaltspeech_Diatheke_SessionOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The updated session token.
  public var token: Cobaltspeech_Diatheke_TokenData {
    get {return _token ?? Cobaltspeech_Diatheke_TokenData()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// The list of actions the client should take next,
  /// using the session token returned with this result.
  public var actionList: [Cobaltspeech_Diatheke_ActionData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Cobaltspeech_Diatheke_TokenData? = nil
}

/// Specifies an action that the client application should take.
public struct Cobaltspeech_Diatheke_ActionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Cobaltspeech_Diatheke_ActionData.OneOf_Action? = nil

  /// The user must provide input to Diatheke.
  public var input: Cobaltspeech_Diatheke_WaitForUserAction {
    get {
      if case .input(let v)? = action {return v}
      return Cobaltspeech_Diatheke_WaitForUserAction()
    }
    set {action = .input(newValue)}
  }

  /// The client app must execute the specified command.
  public var command: Cobaltspeech_Diatheke_CommandAction {
    get {
      if case .command(let v)? = action {return v}
      return Cobaltspeech_Diatheke_CommandAction()
    }
    set {action = .command(newValue)}
  }

  /// The client app should provide the reply to the user.
  public var reply: Cobaltspeech_Diatheke_ReplyAction {
    get {
      if case .reply(let v)? = action {return v}
      return Cobaltspeech_Diatheke_ReplyAction()
    }
    set {action = .reply(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    /// The user must provide input to Diatheke.
    case input(Cobaltspeech_Diatheke_WaitForUserAction)
    /// The client app must execute the specified command.
    case command(Cobaltspeech_Diatheke_CommandAction)
    /// The client app should provide the reply to the user.
    case reply(Cobaltspeech_Diatheke_ReplyAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_ActionData.OneOf_Action, rhs: Cobaltspeech_Diatheke_ActionData.OneOf_Action) -> Bool {
      switch (lhs, rhs) {
      case (.input(let l), .input(let r)): return l == r
      case (.command(let l), .command(let r)): return l == r
      case (.reply(let l), .reply(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// This action indicates that Diatheke is expecting user input.
public struct Cobaltspeech_Diatheke_WaitForUserAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if the next user input must begin with a wake-word.
  public var requiresWakeWord: Bool = false

  /// True if the input is required immediately (i.e., in
  /// response to a question Diatheke asked the user). When
  /// false, the client should be allowed to wait indefinitely
  /// for the user to provide input.
  public var immediate: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This action indicates that the client application should
/// execute a command.
public struct Cobaltspeech_Diatheke_CommandAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the command to execute, as defined in the
  /// Diatheke model.
  public var id: String = String()

  public var inputParameters: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This action indicates that the client application should
/// give the provided text to the user. This action may also 
/// be used to synthesize speech with the StreamTTS method.
public struct Cobaltspeech_Diatheke_ReplyAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text of the reply
  public var text: String = String()

  /// TTS model to use with the TTSReply method
  public var lunaModel: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Data to send to the ASR stream. The first message on the
/// stream must be the session token followed by audio data.
public struct Cobaltspeech_Diatheke_ASRInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Cobaltspeech_Diatheke_ASRInput.OneOf_Data? = nil

  /// Session data, used to determine the correct Cubic
  /// model to use for ASR, with other contextual
  /// information.
  public var token: Cobaltspeech_Diatheke_TokenData {
    get {
      if case .token(let v)? = data {return v}
      return Cobaltspeech_Diatheke_TokenData()
    }
    set {data = .token(newValue)}
  }

  /// Audio data to transcribe.
  public var audio: Data {
    get {
      if case .audio(let v)? = data {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {data = .audio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    /// Session data, used to determine the correct Cubic
    /// model to use for ASR, with other contextual
    /// information.
    case token(Cobaltspeech_Diatheke_TokenData)
    /// Audio data to transcribe.
    case audio(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Diatheke_ASRInput.OneOf_Data, rhs: Cobaltspeech_Diatheke_ASRInput.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.token(let l), .token(let r)): return l == r
      case (.audio(let l), .audio(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The result from the ASR stream, sent after the ASR engine
/// has endpointed or the stream was closed by the client.
public struct Cobaltspeech_Diatheke_ASRResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transcription.
  public var text: String = String()

  /// Confidence estimate between 0 and 1. A higher number
  /// represents a higher likelihood of the output being 
  /// correct.
  public var confidence: Double = 0

  /// True if a timeout was defined for the session's current
  /// input state in the Diatheke model, and the timeout
  /// expired before getting a transcription. This timeout
  /// refers to the amount of time a user has to verbally
  /// respond to Diatheke after the ASR stream has been
  /// created, and should not be confused with a network
  /// connection timeout.
  public var timedOut: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains synthesized speech audio. The specific encoding
/// is defined in the server config file.
public struct Cobaltspeech_Diatheke_TTSAudio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audio: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cobaltspeech_Diatheke_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cobaltspeech.diatheke"

extension Cobaltspeech_Diatheke_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diatheke"),
    2: .same(proto: "chosun"),
    3: .same(proto: "cubic"),
    4: .same(proto: "luna"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.diatheke)
      case 2: try decoder.decodeSingularStringField(value: &self.chosun)
      case 3: try decoder.decodeSingularStringField(value: &self.cubic)
      case 4: try decoder.decodeSingularStringField(value: &self.luna)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.diatheke.isEmpty {
      try visitor.visitSingularStringField(value: self.diatheke, fieldNumber: 1)
    }
    if !self.chosun.isEmpty {
      try visitor.visitSingularStringField(value: self.chosun, fieldNumber: 2)
    }
    if !self.cubic.isEmpty {
      try visitor.visitSingularStringField(value: self.cubic, fieldNumber: 3)
    }
    if !self.luna.isEmpty {
      try visitor.visitSingularStringField(value: self.luna, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_VersionResponse, rhs: Cobaltspeech_Diatheke_VersionResponse) -> Bool {
    if lhs.diatheke != rhs.diatheke {return false}
    if lhs.chosun != rhs.chosun {return false}
    if lhs.cubic != rhs.cubic {return false}
    if lhs.luna != rhs.luna {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ListModelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "models"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.models)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.models, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ListModelsResponse, rhs: Cobaltspeech_Diatheke_ListModelsResponse) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ModelInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "language"),
    4: .standard(proto: "asr_sample_rate"),
    5: .standard(proto: "tts_sample_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.language)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.asrSampleRate)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.ttsSampleRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 3)
    }
    if self.asrSampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.asrSampleRate, fieldNumber: 4)
    }
    if self.ttsSampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttsSampleRate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ModelInfo, rhs: Cobaltspeech_Diatheke_ModelInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.language != rhs.language {return false}
    if lhs.asrSampleRate != rhs.asrSampleRate {return false}
    if lhs.ttsSampleRate != rhs.ttsSampleRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SessionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "text"),
    3: .same(proto: "asr"),
    4: .same(proto: "cmd"),
    5: .same(proto: "story"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._token)
      case 2:
        var v: Cobaltspeech_Diatheke_TextInput?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .text(v)}
      case 3:
        var v: Cobaltspeech_Diatheke_ASRResult?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .asr(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .asr(v)}
      case 4:
        var v: Cobaltspeech_Diatheke_CommandResult?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .cmd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .cmd(v)}
      case 5:
        var v: Cobaltspeech_Diatheke_SetStory?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .story(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .story(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    switch self.input {
    case .text(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .asr(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .cmd(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .story(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SessionInput, rhs: Cobaltspeech_Diatheke_SessionInput) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "id"),
    3: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.data)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.metadata)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TokenData, rhs: Cobaltspeech_Diatheke_TokenData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.id != rhs.id {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SessionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionStart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.modelID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SessionStart, rhs: Cobaltspeech_Diatheke_SessionStart) -> Bool {
    if lhs.modelID != rhs.modelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TextInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.text)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TextInput, rhs: Cobaltspeech_Diatheke_TextInput) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_CommandResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "out_parameters"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.outParameters)
      case 3: try decoder.decodeSingularStringField(value: &self.error)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.outParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.outParameters, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_CommandResult, rhs: Cobaltspeech_Diatheke_CommandResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.outParameters != rhs.outParameters {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SetStory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetStory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.storyID)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storyID.isEmpty {
      try visitor.visitSingularStringField(value: self.storyID, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SetStory, rhs: Cobaltspeech_Diatheke_SetStory) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_SessionOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "action_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._token)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.actionList)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.actionList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_SessionOutput, rhs: Cobaltspeech_Diatheke_SessionOutput) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.actionList != rhs.actionList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ActionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "command"),
    3: .same(proto: "reply"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Cobaltspeech_Diatheke_WaitForUserAction?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .input(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .input(v)}
      case 2:
        var v: Cobaltspeech_Diatheke_CommandAction?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .command(v)}
      case 3:
        var v: Cobaltspeech_Diatheke_ReplyAction?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .reply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .reply(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.action {
    case .input(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .command(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .reply(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ActionData, rhs: Cobaltspeech_Diatheke_ActionData) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_WaitForUserAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitForUserAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "requires_wake_word"),
    2: .same(proto: "immediate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.requiresWakeWord)
      case 2: try decoder.decodeSingularBoolField(value: &self.immediate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requiresWakeWord != false {
      try visitor.visitSingularBoolField(value: self.requiresWakeWord, fieldNumber: 1)
    }
    if self.immediate != false {
      try visitor.visitSingularBoolField(value: self.immediate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_WaitForUserAction, rhs: Cobaltspeech_Diatheke_WaitForUserAction) -> Bool {
    if lhs.requiresWakeWord != rhs.requiresWakeWord {return false}
    if lhs.immediate != rhs.immediate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_CommandAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "input_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.inputParameters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.inputParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.inputParameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_CommandAction, rhs: Cobaltspeech_Diatheke_CommandAction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.inputParameters != rhs.inputParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ReplyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplyAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "luna_model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.text)
      case 2: try decoder.decodeSingularStringField(value: &self.lunaModel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.lunaModel.isEmpty {
      try visitor.visitSingularStringField(value: self.lunaModel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ReplyAction, rhs: Cobaltspeech_Diatheke_ReplyAction) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.lunaModel != rhs.lunaModel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ASRInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ASRInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Cobaltspeech_Diatheke_TokenData?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .token(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .token(v)}
      case 2:
        if self.data != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.data = .audio(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.data {
    case .token(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .audio(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ASRInput, rhs: Cobaltspeech_Diatheke_ASRInput) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_ASRResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ASRResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "confidence"),
    3: .same(proto: "timedOut"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.text)
      case 2: try decoder.decodeSingularDoubleField(value: &self.confidence)
      case 3: try decoder.decodeSingularBoolField(value: &self.timedOut)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 2)
    }
    if self.timedOut != false {
      try visitor.visitSingularBoolField(value: self.timedOut, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_ASRResult, rhs: Cobaltspeech_Diatheke_ASRResult) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.timedOut != rhs.timedOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_TTSAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTSAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.audio)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audio.isEmpty {
      try visitor.visitSingularBytesField(value: self.audio, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_TTSAudio, rhs: Cobaltspeech_Diatheke_TTSAudio) -> Bool {
    if lhs.audio != rhs.audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Diatheke_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Diatheke_Empty, rhs: Cobaltspeech_Diatheke_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
