// Code generated by protoc-gen-go. DO NOT EDIT.
// source: diatheke.proto

package diathekepb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// CommandStatus are the resulting states of a command.
type CommandStatus_StatusCode int32

const (
	// SUCCESS indicates that the command was successfully completed, and the
	// dialog state may now move on to the next state.
	CommandStatus_SUCCESS CommandStatus_StatusCode = 0
	// FAILURE indicates that the command was not successfully completed, and
	// the dialog state should be updated accordingly.
	CommandStatus_FAILURE CommandStatus_StatusCode = 1
)

var CommandStatus_StatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILURE",
}

var CommandStatus_StatusCode_value = map[string]int32{
	"SUCCESS": 0,
	"FAILURE": 1,
}

func (x CommandStatus_StatusCode) String() string {
	return proto.EnumName(CommandStatus_StatusCode_name, int32(x))
}

func (CommandStatus_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{8, 0}
}

// The message sent by the server for the `Version` method.
type VersionResponse struct {
	// Server that manages all of the the other components.
	Server               string   `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionResponse) Reset()         { *m = VersionResponse{} }
func (m *VersionResponse) String() string { return proto.CompactTextString(m) }
func (*VersionResponse) ProtoMessage()    {}
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{0}
}

func (m *VersionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionResponse.Unmarshal(m, b)
}
func (m *VersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionResponse.Marshal(b, m, deterministic)
}
func (m *VersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionResponse.Merge(m, src)
}
func (m *VersionResponse) XXX_Size() int {
	return xxx_messageInfo_VersionResponse.Size(m)
}
func (m *VersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VersionResponse proto.InternalMessageInfo

func (m *VersionResponse) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

// The message sent by the server in response to a Models request.
// Returns an array of model names.
type ModelsResponse struct {
	// Array of models available for use.
	Models               []string `protobuf:"bytes,1,rep,name=models,proto3" json:"models,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModelsResponse) Reset()         { *m = ModelsResponse{} }
func (m *ModelsResponse) String() string { return proto.CompactTextString(m) }
func (*ModelsResponse) ProtoMessage()    {}
func (*ModelsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{1}
}

func (m *ModelsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModelsResponse.Unmarshal(m, b)
}
func (m *ModelsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModelsResponse.Marshal(b, m, deterministic)
}
func (m *ModelsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelsResponse.Merge(m, src)
}
func (m *ModelsResponse) XXX_Size() int {
	return xxx_messageInfo_ModelsResponse.Size(m)
}
func (m *ModelsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ModelsResponse proto.InternalMessageInfo

func (m *ModelsResponse) GetModels() []string {
	if m != nil {
		return m.Models
	}
	return nil
}

// Request for the NewSession call.
// TODO: Consider combining the language and model into one string, such as
// `en_US_variant`.
type NewSessionRequest struct {
	// For applications that have more than one model to use for ASR/NLU.
	// ASR grammer can vary between models, as well as sets of commands.
	// Some applications will only have one model.
	Model                string   `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewSessionRequest) Reset()         { *m = NewSessionRequest{} }
func (m *NewSessionRequest) String() string { return proto.CompactTextString(m) }
func (*NewSessionRequest) ProtoMessage()    {}
func (*NewSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{2}
}

func (m *NewSessionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewSessionRequest.Unmarshal(m, b)
}
func (m *NewSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewSessionRequest.Marshal(b, m, deterministic)
}
func (m *NewSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewSessionRequest.Merge(m, src)
}
func (m *NewSessionRequest) XXX_Size() int {
	return xxx_messageInfo_NewSessionRequest.Size(m)
}
func (m *NewSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewSessionRequest proto.InternalMessageInfo

func (m *NewSessionRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

// Simple message that only contains the session ID.
type SessionID struct {
	// Session ID returned from the NewSession call.
	SessionId            string   `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionID) Reset()         { *m = SessionID{} }
func (m *SessionID) String() string { return proto.CompactTextString(m) }
func (*SessionID) ProtoMessage()    {}
func (*SessionID) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{3}
}

func (m *SessionID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SessionID.Unmarshal(m, b)
}
func (m *SessionID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SessionID.Marshal(b, m, deterministic)
}
func (m *SessionID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionID.Merge(m, src)
}
func (m *SessionID) XXX_Size() int {
	return xxx_messageInfo_SessionID.Size(m)
}
func (m *SessionID) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionID.DiscardUnknown(m)
}

var xxx_messageInfo_SessionID proto.InternalMessageInfo

func (m *SessionID) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

// An event from Diatheke in response to either recognized audio or
// submitted text.
type DiathekeEvent struct {
	// Types that are valid to be assigned to Result:
	//	*DiathekeEvent_Command
	//	*DiathekeEvent_Recognize
	//	*DiathekeEvent_Reply
	Result               isDiathekeEvent_Result `protobuf_oneof:"result"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DiathekeEvent) Reset()         { *m = DiathekeEvent{} }
func (m *DiathekeEvent) String() string { return proto.CompactTextString(m) }
func (*DiathekeEvent) ProtoMessage()    {}
func (*DiathekeEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{4}
}

func (m *DiathekeEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DiathekeEvent.Unmarshal(m, b)
}
func (m *DiathekeEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DiathekeEvent.Marshal(b, m, deterministic)
}
func (m *DiathekeEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiathekeEvent.Merge(m, src)
}
func (m *DiathekeEvent) XXX_Size() int {
	return xxx_messageInfo_DiathekeEvent.Size(m)
}
func (m *DiathekeEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_DiathekeEvent.DiscardUnknown(m)
}

var xxx_messageInfo_DiathekeEvent proto.InternalMessageInfo

type isDiathekeEvent_Result interface {
	isDiathekeEvent_Result()
}

type DiathekeEvent_Command struct {
	Command *CommandEvent `protobuf:"bytes,1,opt,name=command,proto3,oneof"`
}

type DiathekeEvent_Recognize struct {
	Recognize *RecognizeEvent `protobuf:"bytes,2,opt,name=recognize,proto3,oneof"`
}

type DiathekeEvent_Reply struct {
	Reply *ReplyEvent `protobuf:"bytes,3,opt,name=reply,proto3,oneof"`
}

func (*DiathekeEvent_Command) isDiathekeEvent_Result() {}

func (*DiathekeEvent_Recognize) isDiathekeEvent_Result() {}

func (*DiathekeEvent_Reply) isDiathekeEvent_Result() {}

func (m *DiathekeEvent) GetResult() isDiathekeEvent_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *DiathekeEvent) GetCommand() *CommandEvent {
	if x, ok := m.GetResult().(*DiathekeEvent_Command); ok {
		return x.Command
	}
	return nil
}

func (m *DiathekeEvent) GetRecognize() *RecognizeEvent {
	if x, ok := m.GetResult().(*DiathekeEvent_Recognize); ok {
		return x.Recognize
	}
	return nil
}

func (m *DiathekeEvent) GetReply() *ReplyEvent {
	if x, ok := m.GetResult().(*DiathekeEvent_Reply); ok {
		return x.Reply
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DiathekeEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DiathekeEvent_Command)(nil),
		(*DiathekeEvent_Recognize)(nil),
		(*DiathekeEvent_Reply)(nil),
	}
}

// A CommandEvent occurs when Diatheke wants the client to execute the
// given command.
type CommandEvent struct {
	// ID of the command that should be run.  i.e. "COM01" for Command #01.
	CommandId string `protobuf:"bytes,1,opt,name=command_id,json=commandId,proto3" json:"command_id,omitempty"`
	// A generic map of parameters (name, value). The parameters are
	// defined in the Diatheke model. Depending on the command, these
	// parameters should be sent back with the CommandStatus update.
	Parameters map[string]string `protobuf:"bytes,2,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// ID to keep track of the dialog state when the command is requested.
	// This field is required in the CommandStatus message so that Diatheke
	// can correctly update the dialog state when CommandFinished is called.
	CommandStateId       string   `protobuf:"bytes,3,opt,name=command_state_id,json=commandStateId,proto3" json:"command_state_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandEvent) Reset()         { *m = CommandEvent{} }
func (m *CommandEvent) String() string { return proto.CompactTextString(m) }
func (*CommandEvent) ProtoMessage()    {}
func (*CommandEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{5}
}

func (m *CommandEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandEvent.Unmarshal(m, b)
}
func (m *CommandEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandEvent.Marshal(b, m, deterministic)
}
func (m *CommandEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandEvent.Merge(m, src)
}
func (m *CommandEvent) XXX_Size() int {
	return xxx_messageInfo_CommandEvent.Size(m)
}
func (m *CommandEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandEvent.DiscardUnknown(m)
}

var xxx_messageInfo_CommandEvent proto.InternalMessageInfo

func (m *CommandEvent) GetCommandId() string {
	if m != nil {
		return m.CommandId
	}
	return ""
}

func (m *CommandEvent) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *CommandEvent) GetCommandStateId() string {
	if m != nil {
		return m.CommandStateId
	}
	return ""
}

// A RecognizeEvent occurs if a session's audio input has a transcription
// available, or if the PushText method was called. In both cases, the
// event will indicate whether the text was recognized as a valid intent
// by the Diatheke model.
type RecognizeEvent struct {
	// The pushed text or transcription of audio sent to Diatheke.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// True if the submitted text or audio transcription was recognized by the
	// Diatheke model as a valid intent or entity.
	ValidInput           bool     `protobuf:"varint,2,opt,name=valid_input,json=validInput,proto3" json:"valid_input,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecognizeEvent) Reset()         { *m = RecognizeEvent{} }
func (m *RecognizeEvent) String() string { return proto.CompactTextString(m) }
func (*RecognizeEvent) ProtoMessage()    {}
func (*RecognizeEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{6}
}

func (m *RecognizeEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognizeEvent.Unmarshal(m, b)
}
func (m *RecognizeEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognizeEvent.Marshal(b, m, deterministic)
}
func (m *RecognizeEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognizeEvent.Merge(m, src)
}
func (m *RecognizeEvent) XXX_Size() int {
	return xxx_messageInfo_RecognizeEvent.Size(m)
}
func (m *RecognizeEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognizeEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RecognizeEvent proto.InternalMessageInfo

func (m *RecognizeEvent) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *RecognizeEvent) GetValidInput() bool {
	if m != nil {
		return m.ValidInput
	}
	return false
}

// A ReplyEvent occurs when Diatheke has a reply in the conversation (not
// to be confused with the server concepts of request and response). These
// correspond to "say" entries in the Diatheke model. For example, it might
// be a prompt for additional information from the user, a status update,
// or a confirmation. ReplyEvents are not generated in response to
// StreamTTS calls.
type ReplyEvent struct {
	// Text of the reply event (defined by the Diatheke model).
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// Label of the reply event (defined by the Diatheke model).
	Label                string   `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplyEvent) Reset()         { *m = ReplyEvent{} }
func (m *ReplyEvent) String() string { return proto.CompactTextString(m) }
func (*ReplyEvent) ProtoMessage()    {}
func (*ReplyEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{7}
}

func (m *ReplyEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReplyEvent.Unmarshal(m, b)
}
func (m *ReplyEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReplyEvent.Marshal(b, m, deterministic)
}
func (m *ReplyEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyEvent.Merge(m, src)
}
func (m *ReplyEvent) XXX_Size() int {
	return xxx_messageInfo_ReplyEvent.Size(m)
}
func (m *ReplyEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyEvent proto.InternalMessageInfo

func (m *ReplyEvent) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ReplyEvent) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// The final status of an executed command.
type CommandStatus struct {
	// session_id should be the same as the status id returned from
	// NewSessionResponse.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// ID of the command as given in the RunCommand object.
	CommandId    string                   `protobuf:"bytes,2,opt,name=command_id,json=commandId,proto3" json:"command_id,omitempty"`
	ReturnStatus CommandStatus_StatusCode `protobuf:"varint,3,opt,name=return_status,json=returnStatus,proto3,enum=cobaltspeech.diatheke.CommandStatus_StatusCode" json:"return_status,omitempty"`
	// The populated output parameters from the RunCommand object. For example,
	// the map might contain the entry "temperature", which was populated with
	// a value of "30" after the command finished.
	OutputParameters map[string]string `protobuf:"bytes,4,rep,name=output_parameters,json=outputParameters,proto3" json:"output_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Set this field with an error message if an a error occured while
	// executing the command.
	ErrorMessageText string `protobuf:"bytes,5,opt,name=error_message_text,json=errorMessageText,proto3" json:"error_message_text,omitempty"`
	// State ID from the original CommandEvent. This field is required for
	// Diatheke to correctly update the dialog state when CommandFinished
	// is called.
	CommandStateId       string   `protobuf:"bytes,6,opt,name=command_state_id,json=commandStateId,proto3" json:"command_state_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandStatus) Reset()         { *m = CommandStatus{} }
func (m *CommandStatus) String() string { return proto.CompactTextString(m) }
func (*CommandStatus) ProtoMessage()    {}
func (*CommandStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{8}
}

func (m *CommandStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandStatus.Unmarshal(m, b)
}
func (m *CommandStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandStatus.Marshal(b, m, deterministic)
}
func (m *CommandStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStatus.Merge(m, src)
}
func (m *CommandStatus) XXX_Size() int {
	return xxx_messageInfo_CommandStatus.Size(m)
}
func (m *CommandStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStatus proto.InternalMessageInfo

func (m *CommandStatus) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *CommandStatus) GetCommandId() string {
	if m != nil {
		return m.CommandId
	}
	return ""
}

func (m *CommandStatus) GetReturnStatus() CommandStatus_StatusCode {
	if m != nil {
		return m.ReturnStatus
	}
	return CommandStatus_SUCCESS
}

func (m *CommandStatus) GetOutputParameters() map[string]string {
	if m != nil {
		return m.OutputParameters
	}
	return nil
}

func (m *CommandStatus) GetErrorMessageText() string {
	if m != nil {
		return m.ErrorMessageText
	}
	return ""
}

func (m *CommandStatus) GetCommandStateId() string {
	if m != nil {
		return m.CommandStateId
	}
	return ""
}

// Provides input audio data for StreamAudioInput. The first message
// sent must contain the session ID only. All subsequent messages
// must contain audio data only.
type AudioInput struct {
	// Types that are valid to be assigned to Request:
	//	*AudioInput_SessionId
	//	*AudioInput_Data
	Request              isAudioInput_Request `protobuf_oneof:"request"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AudioInput) Reset()         { *m = AudioInput{} }
func (m *AudioInput) String() string { return proto.CompactTextString(m) }
func (*AudioInput) ProtoMessage()    {}
func (*AudioInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{9}
}

func (m *AudioInput) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AudioInput.Unmarshal(m, b)
}
func (m *AudioInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AudioInput.Marshal(b, m, deterministic)
}
func (m *AudioInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioInput.Merge(m, src)
}
func (m *AudioInput) XXX_Size() int {
	return xxx_messageInfo_AudioInput.Size(m)
}
func (m *AudioInput) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioInput.DiscardUnknown(m)
}

var xxx_messageInfo_AudioInput proto.InternalMessageInfo

type isAudioInput_Request interface {
	isAudioInput_Request()
}

type AudioInput_SessionId struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3,oneof"`
}

type AudioInput_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*AudioInput_SessionId) isAudioInput_Request() {}

func (*AudioInput_Data) isAudioInput_Request() {}

func (m *AudioInput) GetRequest() isAudioInput_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *AudioInput) GetSessionId() string {
	if x, ok := m.GetRequest().(*AudioInput_SessionId); ok {
		return x.SessionId
	}
	return ""
}

func (m *AudioInput) GetData() []byte {
	if x, ok := m.GetRequest().(*AudioInput_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AudioInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AudioInput_SessionId)(nil),
		(*AudioInput_Data)(nil),
	}
}

// An AudioReply is the verbal and textual reply that Diatheke returns as
// part of a conversation (not to be confused with the server concepts of
// request and response).
type AudioReply struct {
	// The label defined in the Diatheke model. Identifies which "say" entry
	// in the model this message corresponds to.
	Label string `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	// Types that are valid to be assigned to OutputMessage:
	//	*AudioReply_Text
	//	*AudioReply_Data
	//	*AudioReply_End
	OutputMessage        isAudioReply_OutputMessage `protobuf_oneof:"output_message"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *AudioReply) Reset()         { *m = AudioReply{} }
func (m *AudioReply) String() string { return proto.CompactTextString(m) }
func (*AudioReply) ProtoMessage()    {}
func (*AudioReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{10}
}

func (m *AudioReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AudioReply.Unmarshal(m, b)
}
func (m *AudioReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AudioReply.Marshal(b, m, deterministic)
}
func (m *AudioReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioReply.Merge(m, src)
}
func (m *AudioReply) XXX_Size() int {
	return xxx_messageInfo_AudioReply.Size(m)
}
func (m *AudioReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioReply.DiscardUnknown(m)
}

var xxx_messageInfo_AudioReply proto.InternalMessageInfo

func (m *AudioReply) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type isAudioReply_OutputMessage interface {
	isAudioReply_OutputMessage()
}

type AudioReply_Text struct {
	Text string `protobuf:"bytes,2,opt,name=text,proto3,oneof"`
}

type AudioReply_Data struct {
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3,oneof"`
}

type AudioReply_End struct {
	End *Empty `protobuf:"bytes,4,opt,name=end,proto3,oneof"`
}

func (*AudioReply_Text) isAudioReply_OutputMessage() {}

func (*AudioReply_Data) isAudioReply_OutputMessage() {}

func (*AudioReply_End) isAudioReply_OutputMessage() {}

func (m *AudioReply) GetOutputMessage() isAudioReply_OutputMessage {
	if m != nil {
		return m.OutputMessage
	}
	return nil
}

func (m *AudioReply) GetText() string {
	if x, ok := m.GetOutputMessage().(*AudioReply_Text); ok {
		return x.Text
	}
	return ""
}

func (m *AudioReply) GetData() []byte {
	if x, ok := m.GetOutputMessage().(*AudioReply_Data); ok {
		return x.Data
	}
	return nil
}

func (m *AudioReply) GetEnd() *Empty {
	if x, ok := m.GetOutputMessage().(*AudioReply_End); ok {
		return x.End
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AudioReply) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AudioReply_Text)(nil),
		(*AudioReply_Data)(nil),
		(*AudioReply_End)(nil),
	}
}

// Request to push text to Diatheke as part of a conversation.
type PushTextRequest struct {
	// Session ID returned from the NewSession call.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// User input. This could be a transcription from manually run ASR,
	// text selected from a dropdown list, entered in a prompt, etc.
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PushTextRequest) Reset()         { *m = PushTextRequest{} }
func (m *PushTextRequest) String() string { return proto.CompactTextString(m) }
func (*PushTextRequest) ProtoMessage()    {}
func (*PushTextRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{11}
}

func (m *PushTextRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PushTextRequest.Unmarshal(m, b)
}
func (m *PushTextRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PushTextRequest.Marshal(b, m, deterministic)
}
func (m *PushTextRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushTextRequest.Merge(m, src)
}
func (m *PushTextRequest) XXX_Size() int {
	return xxx_messageInfo_PushTextRequest.Size(m)
}
func (m *PushTextRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushTextRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushTextRequest proto.InternalMessageInfo

func (m *PushTextRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *PushTextRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// Request for streaming ASR unrelated to a session.
type ASRRequest struct {
	// Types that are valid to be assigned to AsrData:
	//	*ASRRequest_Model
	//	*ASRRequest_Audio
	AsrData              isASRRequest_AsrData `protobuf_oneof:"asr_data"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ASRRequest) Reset()         { *m = ASRRequest{} }
func (m *ASRRequest) String() string { return proto.CompactTextString(m) }
func (*ASRRequest) ProtoMessage()    {}
func (*ASRRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{12}
}

func (m *ASRRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ASRRequest.Unmarshal(m, b)
}
func (m *ASRRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ASRRequest.Marshal(b, m, deterministic)
}
func (m *ASRRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ASRRequest.Merge(m, src)
}
func (m *ASRRequest) XXX_Size() int {
	return xxx_messageInfo_ASRRequest.Size(m)
}
func (m *ASRRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ASRRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ASRRequest proto.InternalMessageInfo

type isASRRequest_AsrData interface {
	isASRRequest_AsrData()
}

type ASRRequest_Model struct {
	Model string `protobuf:"bytes,1,opt,name=model,proto3,oneof"`
}

type ASRRequest_Audio struct {
	Audio []byte `protobuf:"bytes,2,opt,name=audio,proto3,oneof"`
}

func (*ASRRequest_Model) isASRRequest_AsrData() {}

func (*ASRRequest_Audio) isASRRequest_AsrData() {}

func (m *ASRRequest) GetAsrData() isASRRequest_AsrData {
	if m != nil {
		return m.AsrData
	}
	return nil
}

func (m *ASRRequest) GetModel() string {
	if x, ok := m.GetAsrData().(*ASRRequest_Model); ok {
		return x.Model
	}
	return ""
}

func (m *ASRRequest) GetAudio() []byte {
	if x, ok := m.GetAsrData().(*ASRRequest_Audio); ok {
		return x.Audio
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ASRRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ASRRequest_Model)(nil),
		(*ASRRequest_Audio)(nil),
	}
}

// ASRResponse contains speech recognition results.
type ASRResponse struct {
	// Text is the Cubic engine's formatted transcript of pushed audio.
	// This field will be the 1-best alternative.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// The confidence score is a floating point number between 0.0 - 1.0. A
	// score of 1.0 indicates that the ASR engine is 100% confident in the
	// transcription.
	ConfidenceScore      float64  `protobuf:"fixed64,2,opt,name=confidence_score,json=confidenceScore,proto3" json:"confidence_score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ASRResponse) Reset()         { *m = ASRResponse{} }
func (m *ASRResponse) String() string { return proto.CompactTextString(m) }
func (*ASRResponse) ProtoMessage()    {}
func (*ASRResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{13}
}

func (m *ASRResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ASRResponse.Unmarshal(m, b)
}
func (m *ASRResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ASRResponse.Marshal(b, m, deterministic)
}
func (m *ASRResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ASRResponse.Merge(m, src)
}
func (m *ASRResponse) XXX_Size() int {
	return xxx_messageInfo_ASRResponse.Size(m)
}
func (m *ASRResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ASRResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ASRResponse proto.InternalMessageInfo

func (m *ASRResponse) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ASRResponse) GetConfidenceScore() float64 {
	if m != nil {
		return m.ConfidenceScore
	}
	return 0
}

// Request to synthesize speech unrelated to a session.
type TTSRequest struct {
	// The model to use for TTS (defined in the server config file).
	Model string `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// Text to synthesize
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TTSRequest) Reset()         { *m = TTSRequest{} }
func (m *TTSRequest) String() string { return proto.CompactTextString(m) }
func (*TTSRequest) ProtoMessage()    {}
func (*TTSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{14}
}

func (m *TTSRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TTSRequest.Unmarshal(m, b)
}
func (m *TTSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TTSRequest.Marshal(b, m, deterministic)
}
func (m *TTSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TTSRequest.Merge(m, src)
}
func (m *TTSRequest) XXX_Size() int {
	return xxx_messageInfo_TTSRequest.Size(m)
}
func (m *TTSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TTSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TTSRequest proto.InternalMessageInfo

func (m *TTSRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *TTSRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// Response for text-to-speech unrelated to a session.
type TTSResponse struct {
	// The synthesized audio data. The data encoding will match what was
	// specified in the server configuration.
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TTSResponse) Reset()         { *m = TTSResponse{} }
func (m *TTSResponse) String() string { return proto.CompactTextString(m) }
func (*TTSResponse) ProtoMessage()    {}
func (*TTSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{15}
}

func (m *TTSResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TTSResponse.Unmarshal(m, b)
}
func (m *TTSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TTSResponse.Marshal(b, m, deterministic)
}
func (m *TTSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TTSResponse.Merge(m, src)
}
func (m *TTSResponse) XXX_Size() int {
	return xxx_messageInfo_TTSResponse.Size(m)
}
func (m *TTSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TTSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TTSResponse proto.InternalMessageInfo

func (m *TTSResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{16}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cobaltspeech.diatheke.CommandStatus_StatusCode", CommandStatus_StatusCode_name, CommandStatus_StatusCode_value)
	proto.RegisterType((*VersionResponse)(nil), "cobaltspeech.diatheke.VersionResponse")
	proto.RegisterType((*ModelsResponse)(nil), "cobaltspeech.diatheke.ModelsResponse")
	proto.RegisterType((*NewSessionRequest)(nil), "cobaltspeech.diatheke.NewSessionRequest")
	proto.RegisterType((*SessionID)(nil), "cobaltspeech.diatheke.SessionID")
	proto.RegisterType((*DiathekeEvent)(nil), "cobaltspeech.diatheke.DiathekeEvent")
	proto.RegisterType((*CommandEvent)(nil), "cobaltspeech.diatheke.CommandEvent")
	proto.RegisterMapType((map[string]string)(nil), "cobaltspeech.diatheke.CommandEvent.ParametersEntry")
	proto.RegisterType((*RecognizeEvent)(nil), "cobaltspeech.diatheke.RecognizeEvent")
	proto.RegisterType((*ReplyEvent)(nil), "cobaltspeech.diatheke.ReplyEvent")
	proto.RegisterType((*CommandStatus)(nil), "cobaltspeech.diatheke.CommandStatus")
	proto.RegisterMapType((map[string]string)(nil), "cobaltspeech.diatheke.CommandStatus.OutputParametersEntry")
	proto.RegisterType((*AudioInput)(nil), "cobaltspeech.diatheke.AudioInput")
	proto.RegisterType((*AudioReply)(nil), "cobaltspeech.diatheke.AudioReply")
	proto.RegisterType((*PushTextRequest)(nil), "cobaltspeech.diatheke.PushTextRequest")
	proto.RegisterType((*ASRRequest)(nil), "cobaltspeech.diatheke.ASRRequest")
	proto.RegisterType((*ASRResponse)(nil), "cobaltspeech.diatheke.ASRResponse")
	proto.RegisterType((*TTSRequest)(nil), "cobaltspeech.diatheke.TTSRequest")
	proto.RegisterType((*TTSResponse)(nil), "cobaltspeech.diatheke.TTSResponse")
	proto.RegisterType((*Empty)(nil), "cobaltspeech.diatheke.Empty")
}

func init() { proto.RegisterFile("diatheke.proto", fileDescriptor_6d1ed59c94a181ed) }

var fileDescriptor_6d1ed59c94a181ed = []byte{
	// 981 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xef, 0x8e, 0xdb, 0x44,
	0x10, 0xb7, 0x93, 0xcb, 0xbf, 0x49, 0x2e, 0x49, 0x57, 0xd7, 0x2a, 0x8a, 0x40, 0xbd, 0x2e, 0xa5,
	0xca, 0x21, 0x14, 0x4e, 0x57, 0x09, 0x41, 0x25, 0x84, 0x2e, 0x39, 0x57, 0x17, 0xa9, 0xbd, 0x16,
	0x3b, 0x6d, 0x51, 0x25, 0x14, 0x7c, 0xf1, 0x72, 0x67, 0xd5, 0xb1, 0xcd, 0xee, 0xfa, 0x20, 0x3c,
	0x06, 0x6f, 0x86, 0xf8, 0xca, 0x1b, 0xf0, 0x12, 0x68, 0xff, 0xf8, 0xec, 0x4b, 0xe3, 0x24, 0x7c,
	0x8a, 0x67, 0x76, 0xe6, 0xb7, 0x33, 0xbf, 0x99, 0x9d, 0x09, 0xb4, 0x3d, 0xdf, 0xe5, 0xd7, 0xe4,
	0x03, 0x19, 0xc6, 0x34, 0xe2, 0x11, 0xba, 0x3f, 0x8f, 0x2e, 0xdd, 0x80, 0xb3, 0x98, 0x90, 0xf9,
	0xf5, 0x30, 0x3d, 0xc4, 0x47, 0xd0, 0x79, 0x4b, 0x28, 0xf3, 0xa3, 0xd0, 0x26, 0x2c, 0x8e, 0x42,
	0x46, 0xd0, 0x03, 0xa8, 0x32, 0x42, 0x6f, 0x08, 0xed, 0x99, 0x87, 0xe6, 0xa0, 0x61, 0x6b, 0x09,
	0x0f, 0xa0, 0xfd, 0x32, 0xf2, 0x48, 0xc0, 0xf2, 0x96, 0x0b, 0xa9, 0xe9, 0x99, 0x87, 0x65, 0x61,
	0xa9, 0x24, 0x7c, 0x04, 0xf7, 0x2e, 0xc8, 0x6f, 0x0e, 0x61, 0x0a, 0xf7, 0xd7, 0x84, 0x30, 0x8e,
	0x0e, 0xa0, 0x22, 0x8f, 0x35, 0xaa, 0x12, 0xf0, 0x17, 0xd0, 0xd0, 0x76, 0x93, 0x33, 0xf4, 0x29,
	0x00, 0x53, 0xc2, 0xcc, 0xf7, 0xb4, 0x5d, 0x43, 0x6b, 0x26, 0x1e, 0xfe, 0xc7, 0x84, 0xfd, 0x33,
	0x1d, 0xb8, 0x75, 0x43, 0x42, 0x8e, 0xbe, 0x87, 0xda, 0x3c, 0x5a, 0x2c, 0xdc, 0x50, 0x59, 0x37,
	0x4f, 0x3e, 0x1b, 0xae, 0x4d, 0x73, 0x38, 0x56, 0x56, 0xd2, 0xeb, 0xdc, 0xb0, 0x53, 0x2f, 0x64,
	0x41, 0x83, 0x92, 0x79, 0x74, 0x15, 0xfa, 0x7f, 0x90, 0x5e, 0x49, 0x42, 0x7c, 0x5e, 0x00, 0x61,
	0xa7, 0x76, 0x29, 0x48, 0xe6, 0x89, 0xbe, 0x85, 0x0a, 0x25, 0x71, 0xb0, 0xec, 0x95, 0x25, 0xc4,
	0xa3, 0x42, 0x88, 0x38, 0x58, 0xa6, 0xee, 0xca, 0x63, 0x54, 0x87, 0x2a, 0x25, 0x2c, 0x09, 0x38,
	0xfe, 0xd7, 0x84, 0x56, 0x3e, 0x4e, 0x41, 0x87, 0x8e, 0x33, 0x47, 0x87, 0xd6, 0x4c, 0x3c, 0xe4,
	0x00, 0xc4, 0x2e, 0x75, 0x17, 0x84, 0x13, 0xca, 0x7a, 0xa5, 0xc3, 0xf2, 0xa0, 0x79, 0xf2, 0x74,
	0x87, 0xfc, 0x87, 0xaf, 0x6f, 0xbd, 0xac, 0x90, 0xd3, 0xa5, 0x9d, 0x83, 0x41, 0x03, 0xe8, 0xa6,
	0x77, 0x32, 0xee, 0x72, 0x22, 0x6e, 0x2e, 0xcb, 0x9b, 0xdb, 0x5a, 0xef, 0x08, 0xf5, 0xc4, 0xeb,
	0x7f, 0x07, 0x9d, 0x15, 0x20, 0xd4, 0x85, 0xf2, 0x07, 0xb2, 0xd4, 0x91, 0x8a, 0x4f, 0x51, 0xf4,
	0x1b, 0x37, 0x48, 0x14, 0xb7, 0x0d, 0x5b, 0x09, 0xcf, 0x4a, 0xdf, 0x98, 0xd8, 0x82, 0xf6, 0x5d,
	0x46, 0x11, 0x82, 0x3d, 0x4e, 0x7e, 0xe7, 0xda, 0x5d, 0x7e, 0xa3, 0x87, 0xd0, 0xbc, 0x71, 0x03,
	0xdf, 0x9b, 0xf9, 0x61, 0x9c, 0x70, 0x89, 0x52, 0xb7, 0x41, 0xaa, 0x26, 0x42, 0x83, 0xbf, 0x06,
	0xc8, 0x58, 0x5d, 0x0b, 0x71, 0x00, 0x95, 0xc0, 0xbd, 0x24, 0x41, 0x1a, 0x82, 0x14, 0xf0, 0x5f,
	0x65, 0xd8, 0x1f, 0x67, 0x09, 0x25, 0x6c, 0x4b, 0xf3, 0xad, 0x14, 0xa3, 0xb4, 0x5a, 0x8c, 0x29,
	0xec, 0x53, 0xc2, 0x13, 0x1a, 0x4a, 0xda, 0x12, 0x26, 0x49, 0x6b, 0x9f, 0x7c, 0xb5, 0xb9, 0x1e,
	0xea, 0xea, 0xa1, 0xfa, 0x19, 0x47, 0x1e, 0xb1, 0x5b, 0x0a, 0x45, 0xc7, 0x74, 0x05, 0xf7, 0xa2,
	0x84, 0xc7, 0x09, 0x9f, 0xe5, 0x2a, 0xbd, 0x27, 0x2b, 0xfd, 0x6c, 0x27, 0xe4, 0x57, 0xd2, 0x7b,
	0xb5, 0xe0, 0xdd, 0x68, 0x45, 0x8d, 0xbe, 0x04, 0x44, 0x28, 0x8d, 0xe8, 0x6c, 0x41, 0x18, 0x73,
	0xaf, 0xc8, 0x4c, 0xd2, 0x58, 0x91, 0x59, 0x76, 0xe5, 0xc9, 0x4b, 0x75, 0x30, 0x15, 0x94, 0xae,
	0x6b, 0x92, 0xea, 0xda, 0x26, 0x19, 0xc3, 0xfd, 0xb5, 0x21, 0xfc, 0xaf, 0x56, 0x79, 0x02, 0x90,
	0x31, 0x84, 0x9a, 0x50, 0x73, 0xde, 0x8c, 0xc7, 0x96, 0xe3, 0x74, 0x0d, 0x21, 0x3c, 0x3f, 0x9d,
	0xbc, 0x78, 0x63, 0x5b, 0x5d, 0x13, 0x5f, 0x00, 0x9c, 0x26, 0x9e, 0x1f, 0xc9, 0xce, 0x40, 0x0f,
	0x3f, 0xae, 0xa7, 0x78, 0xb4, 0x59, 0x45, 0x0f, 0x60, 0xcf, 0x73, 0xb9, 0x2b, 0xef, 0x6b, 0x9d,
	0x1b, 0xb6, 0x94, 0x46, 0x0d, 0xa8, 0x51, 0x35, 0xb1, 0xf0, 0x9f, 0xa6, 0x06, 0x94, 0x1d, 0x96,
	0x35, 0x92, 0x99, 0x6b, 0x24, 0x81, 0x22, 0xb9, 0x2a, 0xe9, 0x0b, 0xd2, 0xa6, 0x53, 0xd8, 0xe5,
	0x3c, 0x36, 0x3a, 0x86, 0x32, 0x09, 0xbd, 0xde, 0x9e, 0x1c, 0x12, 0x9f, 0x14, 0x14, 0xd0, 0x5a,
	0xc4, 0x7c, 0x79, 0x6e, 0xd8, 0xc2, 0x74, 0xd4, 0x85, 0xb6, 0x6e, 0x00, 0x5d, 0x18, 0x7c, 0x06,
	0x9d, 0xd7, 0x09, 0xbb, 0x16, 0x75, 0x48, 0x27, 0xeb, 0x96, 0xce, 0x45, 0xf9, 0x08, 0x55, 0x7c,
	0xf8, 0x1c, 0xe0, 0xd4, 0xb1, 0x53, 0x80, 0x07, 0x77, 0x46, 0xb3, 0x98, 0x4d, 0x52, 0x14, 0x7a,
	0x57, 0xe4, 0x7f, 0x4b, 0x91, 0x12, 0x47, 0x00, 0x75, 0x97, 0xd1, 0x99, 0xc8, 0x09, 0xbf, 0x80,
	0xa6, 0x44, 0xd2, 0x2b, 0x61, 0xdd, 0x0b, 0x3c, 0x12, 0xed, 0x12, 0xfe, 0xe2, 0x7b, 0x24, 0x9c,
	0x93, 0x19, 0x9b, 0x47, 0x54, 0x15, 0xd9, 0xb4, 0x3b, 0x99, 0xde, 0x11, 0x6a, 0xf1, 0x9c, 0xa7,
	0x53, 0x67, 0xe3, 0xca, 0x58, 0x9b, 0xcf, 0x23, 0x68, 0x4a, 0xbf, 0x2c, 0x0a, 0x49, 0xbf, 0xf0,
	0x6b, 0x29, 0xf2, 0x71, 0x0d, 0x2a, 0x92, 0xda, 0x93, 0xbf, 0x6b, 0x50, 0x4f, 0xd7, 0x08, 0xfa,
	0x01, 0x6a, 0x7a, 0xff, 0xa1, 0x8d, 0x05, 0xe9, 0x3f, 0x29, 0x38, 0x5d, 0xd9, 0x9e, 0xd8, 0x40,
	0xaf, 0xa0, 0xaa, 0xf6, 0xe4, 0x16, 0xc4, 0xa2, 0x45, 0x73, 0x77, 0xc9, 0x62, 0x03, 0xbd, 0x07,
	0xc8, 0xd6, 0x29, 0x1a, 0x14, 0xb8, 0x7d, 0xb4, 0x71, 0xfb, 0x87, 0x05, 0x96, 0xb7, 0x0b, 0x17,
	0x1b, 0xe8, 0x02, 0xc0, 0x0a, 0xbd, 0x14, 0x7b, 0xab, 0x47, 0x7f, 0x63, 0x4a, 0xd8, 0x40, 0x3f,
	0x03, 0xd2, 0xc6, 0x72, 0x22, 0x3b, 0x9c, 0x12, 0x77, 0xb1, 0x03, 0xee, 0xe3, 0x02, 0x8b, 0x3b,
	0xfb, 0x1e, 0x1b, 0xc7, 0x26, 0x7a, 0x07, 0x1d, 0x3d, 0xe3, 0x9e, 0xfb, 0xa1, 0xcf, 0xae, 0x89,
	0x87, 0x1e, 0xef, 0x32, 0x0b, 0xb7, 0x86, 0xfe, 0x0e, 0xba, 0x2a, 0xdc, 0xdc, 0x10, 0x29, 0xda,
	0xe4, 0x99, 0xc9, 0x36, 0xd8, 0x81, 0x89, 0x7e, 0x02, 0x94, 0x03, 0x16, 0xc3, 0xc4, 0x27, 0x6c,
	0x07, 0x4e, 0x36, 0x5e, 0x2e, 0x67, 0x92, 0x24, 0xc4, 0x86, 0x7a, 0x3a, 0x11, 0x50, 0x51, 0x97,
	0xae, 0x8c, 0x8c, 0xad, 0x5c, 0xfc, 0x08, 0x0d, 0x1d, 0xb2, 0x63, 0x17, 0x93, 0x70, 0x3b, 0x41,
	0xfa, 0x78, 0x93, 0x49, 0xda, 0xc8, 0x03, 0xf3, 0xd8, 0x44, 0x6f, 0x53, 0xe4, 0xe9, 0xd4, 0x29,
	0x44, 0xce, 0x66, 0x40, 0x21, 0x72, 0xee, 0xb9, 0x0b, 0x16, 0x46, 0xad, 0xf7, 0x90, 0x9e, 0xc5,
	0x97, 0x97, 0x55, 0xf9, 0xa7, 0xf7, 0xe9, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x85, 0xcf, 0x0a,
	0xca, 0x06, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DiathekeClient is the client API for Diatheke service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DiathekeClient interface {
	// Queries the Version of the Server.
	Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	// Models will return a list of available versions.  Model values from
	// this list may be used in NewSession calls.
	Models(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ModelsResponse, error)
	// Requests a new session with the given config and returns the session
	// ID, which is required for other rpc methods.
	NewSession(ctx context.Context, in *NewSessionRequest, opts ...grpc.CallOption) (*SessionID, error)
	// Terminates an existing session and closes any open event streams.
	// It is an error if the SessionEndRequest has an invalid SessionID.
	EndSession(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*Empty, error)
	// Requests a new event stream for the given session.
	SessionEventStream(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (Diatheke_SessionEventStreamClient, error)
	// Notify Diatheke when a command has completed so that it may update
	// the dialog state. The initial command request will come as part of
	// a DiathekeEvent. While not strictly required (depeding on the model
	// and command), it is best practice to always call this method when a
	// command is complete. Cases where it is required include when the
	// command has output parameters, or when the command is followed by
	// another action in the Diatheke model.
	CommandFinished(ctx context.Context, in *CommandStatus, opts ...grpc.CallOption) (*Empty, error)
	// Begin an audio input stream for a session. The first message to
	// the server should specify the sessionID, with binary audio data pushed
	// for every subsequent message. As the audio is recognized, Diatheke
	// will respond with appropriate events on the session's event stream.
	//
	// While it is allowed to call this multiple times during a single session,
	// clients should never have multiple audio input streams running concurrently
	// for the same session (the audio may mix and result in unpredictable
	// behavior). Previous audio streams should always be closed before starting
	// a new one.
	StreamAudioInput(ctx context.Context, opts ...grpc.CallOption) (Diatheke_StreamAudioInputClient, error)
	// Create an audio reply stream for a session. The returned stream
	// will receive replies ("say" entries in the Diatheke model) from the
	// server as they occur in the conversation. For each "say" entry, the
	// stream will first receive the text to synthesize (defined by the model),
	// followed by one or more messages containing the synthesized audio bytes.
	// The "say" entry will end with a message indicating that TTS for that
	// entry is complete.
	// NOTE: The text in the first message of an audio reply is the same that
	//       will be received in the session's event stream.
	StreamAudioReplies(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (Diatheke_StreamAudioRepliesClient, error)
	// Push text to Diatheke as part of the conversation for a session.
	// Diatheke will respond with an appropriate event on the session's
	// event stream based on whether the given text was recognized as a
	// valid intent or not.
	PushText(ctx context.Context, in *PushTextRequest, opts ...grpc.CallOption) (*Empty, error)
	// Manually run streaming ASR unrelated to any session by pushing
	// audio data to the server on the audio stream. As transcriptions
	// become available, the server will return them on the ASRResponse
	// stream. The transcriptions may then be used for, e.g., the PushText
	// method. This function is provided as a convenience.
	StreamASR(ctx context.Context, opts ...grpc.CallOption) (Diatheke_StreamASRClient, error)
	// Manually run streaming TTS. The Audio stream will receive
	// binary audio data as it is synthesized and will close automatically
	// when synthesis is complete. This function is provided as a
	// convenience.
	StreamTTS(ctx context.Context, in *TTSRequest, opts ...grpc.CallOption) (Diatheke_StreamTTSClient, error)
}

type diathekeClient struct {
	cc *grpc.ClientConn
}

func NewDiathekeClient(cc *grpc.ClientConn) DiathekeClient {
	return &diathekeClient{cc}
}

func (c *diathekeClient) Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) Models(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ModelsResponse, error) {
	out := new(ModelsResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/Models", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) NewSession(ctx context.Context, in *NewSessionRequest, opts ...grpc.CallOption) (*SessionID, error) {
	out := new(SessionID)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/NewSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) EndSession(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/EndSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) SessionEventStream(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (Diatheke_SessionEventStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[0], "/cobaltspeech.diatheke.Diatheke/SessionEventStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeSessionEventStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Diatheke_SessionEventStreamClient interface {
	Recv() (*DiathekeEvent, error)
	grpc.ClientStream
}

type diathekeSessionEventStreamClient struct {
	grpc.ClientStream
}

func (x *diathekeSessionEventStreamClient) Recv() (*DiathekeEvent, error) {
	m := new(DiathekeEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diathekeClient) CommandFinished(ctx context.Context, in *CommandStatus, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/CommandFinished", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) StreamAudioInput(ctx context.Context, opts ...grpc.CallOption) (Diatheke_StreamAudioInputClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[1], "/cobaltspeech.diatheke.Diatheke/StreamAudioInput", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeStreamAudioInputClient{stream}
	return x, nil
}

type Diatheke_StreamAudioInputClient interface {
	Send(*AudioInput) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type diathekeStreamAudioInputClient struct {
	grpc.ClientStream
}

func (x *diathekeStreamAudioInputClient) Send(m *AudioInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *diathekeStreamAudioInputClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diathekeClient) StreamAudioReplies(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (Diatheke_StreamAudioRepliesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[2], "/cobaltspeech.diatheke.Diatheke/StreamAudioReplies", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeStreamAudioRepliesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Diatheke_StreamAudioRepliesClient interface {
	Recv() (*AudioReply, error)
	grpc.ClientStream
}

type diathekeStreamAudioRepliesClient struct {
	grpc.ClientStream
}

func (x *diathekeStreamAudioRepliesClient) Recv() (*AudioReply, error) {
	m := new(AudioReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diathekeClient) PushText(ctx context.Context, in *PushTextRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/PushText", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) StreamASR(ctx context.Context, opts ...grpc.CallOption) (Diatheke_StreamASRClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[3], "/cobaltspeech.diatheke.Diatheke/StreamASR", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeStreamASRClient{stream}
	return x, nil
}

type Diatheke_StreamASRClient interface {
	Send(*ASRRequest) error
	Recv() (*ASRResponse, error)
	grpc.ClientStream
}

type diathekeStreamASRClient struct {
	grpc.ClientStream
}

func (x *diathekeStreamASRClient) Send(m *ASRRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *diathekeStreamASRClient) Recv() (*ASRResponse, error) {
	m := new(ASRResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diathekeClient) StreamTTS(ctx context.Context, in *TTSRequest, opts ...grpc.CallOption) (Diatheke_StreamTTSClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[4], "/cobaltspeech.diatheke.Diatheke/StreamTTS", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeStreamTTSClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Diatheke_StreamTTSClient interface {
	Recv() (*TTSResponse, error)
	grpc.ClientStream
}

type diathekeStreamTTSClient struct {
	grpc.ClientStream
}

func (x *diathekeStreamTTSClient) Recv() (*TTSResponse, error) {
	m := new(TTSResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DiathekeServer is the server API for Diatheke service.
type DiathekeServer interface {
	// Queries the Version of the Server.
	Version(context.Context, *Empty) (*VersionResponse, error)
	// Models will return a list of available versions.  Model values from
	// this list may be used in NewSession calls.
	Models(context.Context, *Empty) (*ModelsResponse, error)
	// Requests a new session with the given config and returns the session
	// ID, which is required for other rpc methods.
	NewSession(context.Context, *NewSessionRequest) (*SessionID, error)
	// Terminates an existing session and closes any open event streams.
	// It is an error if the SessionEndRequest has an invalid SessionID.
	EndSession(context.Context, *SessionID) (*Empty, error)
	// Requests a new event stream for the given session.
	SessionEventStream(*SessionID, Diatheke_SessionEventStreamServer) error
	// Notify Diatheke when a command has completed so that it may update
	// the dialog state. The initial command request will come as part of
	// a DiathekeEvent. While not strictly required (depeding on the model
	// and command), it is best practice to always call this method when a
	// command is complete. Cases where it is required include when the
	// command has output parameters, or when the command is followed by
	// another action in the Diatheke model.
	CommandFinished(context.Context, *CommandStatus) (*Empty, error)
	// Begin an audio input stream for a session. The first message to
	// the server should specify the sessionID, with binary audio data pushed
	// for every subsequent message. As the audio is recognized, Diatheke
	// will respond with appropriate events on the session's event stream.
	//
	// While it is allowed to call this multiple times during a single session,
	// clients should never have multiple audio input streams running concurrently
	// for the same session (the audio may mix and result in unpredictable
	// behavior). Previous audio streams should always be closed before starting
	// a new one.
	StreamAudioInput(Diatheke_StreamAudioInputServer) error
	// Create an audio reply stream for a session. The returned stream
	// will receive replies ("say" entries in the Diatheke model) from the
	// server as they occur in the conversation. For each "say" entry, the
	// stream will first receive the text to synthesize (defined by the model),
	// followed by one or more messages containing the synthesized audio bytes.
	// The "say" entry will end with a message indicating that TTS for that
	// entry is complete.
	// NOTE: The text in the first message of an audio reply is the same that
	//       will be received in the session's event stream.
	StreamAudioReplies(*SessionID, Diatheke_StreamAudioRepliesServer) error
	// Push text to Diatheke as part of the conversation for a session.
	// Diatheke will respond with an appropriate event on the session's
	// event stream based on whether the given text was recognized as a
	// valid intent or not.
	PushText(context.Context, *PushTextRequest) (*Empty, error)
	// Manually run streaming ASR unrelated to any session by pushing
	// audio data to the server on the audio stream. As transcriptions
	// become available, the server will return them on the ASRResponse
	// stream. The transcriptions may then be used for, e.g., the PushText
	// method. This function is provided as a convenience.
	StreamASR(Diatheke_StreamASRServer) error
	// Manually run streaming TTS. The Audio stream will receive
	// binary audio data as it is synthesized and will close automatically
	// when synthesis is complete. This function is provided as a
	// convenience.
	StreamTTS(*TTSRequest, Diatheke_StreamTTSServer) error
}

func RegisterDiathekeServer(s *grpc.Server, srv DiathekeServer) {
	s.RegisterService(&_Diatheke_serviceDesc, srv)
}

func _Diatheke_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).Version(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_Models_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).Models(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/Models",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).Models(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_NewSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).NewSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/NewSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).NewSession(ctx, req.(*NewSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/EndSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).EndSession(ctx, req.(*SessionID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_SessionEventStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiathekeServer).SessionEventStream(m, &diathekeSessionEventStreamServer{stream})
}

type Diatheke_SessionEventStreamServer interface {
	Send(*DiathekeEvent) error
	grpc.ServerStream
}

type diathekeSessionEventStreamServer struct {
	grpc.ServerStream
}

func (x *diathekeSessionEventStreamServer) Send(m *DiathekeEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Diatheke_CommandFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).CommandFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/CommandFinished",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).CommandFinished(ctx, req.(*CommandStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_StreamAudioInput_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DiathekeServer).StreamAudioInput(&diathekeStreamAudioInputServer{stream})
}

type Diatheke_StreamAudioInputServer interface {
	SendAndClose(*Empty) error
	Recv() (*AudioInput, error)
	grpc.ServerStream
}

type diathekeStreamAudioInputServer struct {
	grpc.ServerStream
}

func (x *diathekeStreamAudioInputServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *diathekeStreamAudioInputServer) Recv() (*AudioInput, error) {
	m := new(AudioInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Diatheke_StreamAudioReplies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiathekeServer).StreamAudioReplies(m, &diathekeStreamAudioRepliesServer{stream})
}

type Diatheke_StreamAudioRepliesServer interface {
	Send(*AudioReply) error
	grpc.ServerStream
}

type diathekeStreamAudioRepliesServer struct {
	grpc.ServerStream
}

func (x *diathekeStreamAudioRepliesServer) Send(m *AudioReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Diatheke_PushText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushTextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).PushText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/PushText",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).PushText(ctx, req.(*PushTextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_StreamASR_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DiathekeServer).StreamASR(&diathekeStreamASRServer{stream})
}

type Diatheke_StreamASRServer interface {
	Send(*ASRResponse) error
	Recv() (*ASRRequest, error)
	grpc.ServerStream
}

type diathekeStreamASRServer struct {
	grpc.ServerStream
}

func (x *diathekeStreamASRServer) Send(m *ASRResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *diathekeStreamASRServer) Recv() (*ASRRequest, error) {
	m := new(ASRRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Diatheke_StreamTTS_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TTSRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiathekeServer).StreamTTS(m, &diathekeStreamTTSServer{stream})
}

type Diatheke_StreamTTSServer interface {
	Send(*TTSResponse) error
	grpc.ServerStream
}

type diathekeStreamTTSServer struct {
	grpc.ServerStream
}

func (x *diathekeStreamTTSServer) Send(m *TTSResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Diatheke_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cobaltspeech.diatheke.Diatheke",
	HandlerType: (*DiathekeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Diatheke_Version_Handler,
		},
		{
			MethodName: "Models",
			Handler:    _Diatheke_Models_Handler,
		},
		{
			MethodName: "NewSession",
			Handler:    _Diatheke_NewSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _Diatheke_EndSession_Handler,
		},
		{
			MethodName: "CommandFinished",
			Handler:    _Diatheke_CommandFinished_Handler,
		},
		{
			MethodName: "PushText",
			Handler:    _Diatheke_PushText_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SessionEventStream",
			Handler:       _Diatheke_SessionEventStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamAudioInput",
			Handler:       _Diatheke_StreamAudioInput_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamAudioReplies",
			Handler:       _Diatheke_StreamAudioReplies_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamASR",
			Handler:       _Diatheke_StreamASR_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamTTS",
			Handler:       _Diatheke_StreamTTS_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "diatheke.proto",
}
