// Copyright (2021) Cobalt Speech and Language Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.21.0
// 	protoc        v3.11.4
// source: diatheke.proto

package diathekepb

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// Lists the version of Diatheke and the engines it uses.
type VersionResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Dialog management engine
	Diatheke string `protobuf:"bytes,1,opt,name=diatheke,proto3" json:"diatheke,omitempty"`
	// NLU engine
	Chosun string `protobuf:"bytes,2,opt,name=chosun,proto3" json:"chosun,omitempty"`
	// ASR engine
	Cubic string `protobuf:"bytes,3,opt,name=cubic,proto3" json:"cubic,omitempty"`
	// TTS engine
	Luna string `protobuf:"bytes,4,opt,name=luna,proto3" json:"luna,omitempty"`
}

func (x *VersionResponse) Reset() {
	*x = VersionResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VersionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionResponse) ProtoMessage() {}

func (x *VersionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionResponse.ProtoReflect.Descriptor instead.
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{0}
}

func (x *VersionResponse) GetDiatheke() string {
	if x != nil {
		return x.Diatheke
	}
	return ""
}

func (x *VersionResponse) GetChosun() string {
	if x != nil {
		return x.Chosun
	}
	return ""
}

func (x *VersionResponse) GetCubic() string {
	if x != nil {
		return x.Cubic
	}
	return ""
}

func (x *VersionResponse) GetLuna() string {
	if x != nil {
		return x.Luna
	}
	return ""
}

// A list of models available on the Diatheke server.
type ListModelsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Models []*ModelInfo `protobuf:"bytes,1,rep,name=models,proto3" json:"models,omitempty"`
}

func (x *ListModelsResponse) Reset() {
	*x = ListModelsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListModelsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListModelsResponse) ProtoMessage() {}

func (x *ListModelsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListModelsResponse.ProtoReflect.Descriptor instead.
func (*ListModelsResponse) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{1}
}

func (x *ListModelsResponse) GetModels() []*ModelInfo {
	if x != nil {
		return x.Models
	}
	return nil
}

// Information about a single Diatheke model.
type ModelInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Diatheke model ID, which is used to create a new session.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Pretty model name, which may be used for display purposes.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Language code of the model.
	Language string `protobuf:"bytes,3,opt,name=language,proto3" json:"language,omitempty"`
	// The ASR audio sample rate, if ASR is enabled.
	AsrSampleRate uint32 `protobuf:"varint,4,opt,name=asr_sample_rate,json=asrSampleRate,proto3" json:"asr_sample_rate,omitempty"`
	// The TTS audio sample rate, if TTS is enabled.
	TtsSampleRate uint32 `protobuf:"varint,5,opt,name=tts_sample_rate,json=ttsSampleRate,proto3" json:"tts_sample_rate,omitempty"`
}

func (x *ModelInfo) Reset() {
	*x = ModelInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ModelInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModelInfo) ProtoMessage() {}

func (x *ModelInfo) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModelInfo.ProtoReflect.Descriptor instead.
func (*ModelInfo) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{2}
}

func (x *ModelInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ModelInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ModelInfo) GetLanguage() string {
	if x != nil {
		return x.Language
	}
	return ""
}

func (x *ModelInfo) GetAsrSampleRate() uint32 {
	if x != nil {
		return x.AsrSampleRate
	}
	return 0
}

func (x *ModelInfo) GetTtsSampleRate() uint32 {
	if x != nil {
		return x.TtsSampleRate
	}
	return 0
}

// Used by Diatheke to update the session state.
type SessionInput struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The session token.
	Token *TokenData `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Types that are assignable to Input:
	//	*SessionInput_Text
	//	*SessionInput_Asr
	//	*SessionInput_Cmd
	//	*SessionInput_Story
	Input isSessionInput_Input `protobuf_oneof:"input"`
}

func (x *SessionInput) Reset() {
	*x = SessionInput{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SessionInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionInput) ProtoMessage() {}

func (x *SessionInput) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionInput.ProtoReflect.Descriptor instead.
func (*SessionInput) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{3}
}

func (x *SessionInput) GetToken() *TokenData {
	if x != nil {
		return x.Token
	}
	return nil
}

func (m *SessionInput) GetInput() isSessionInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (x *SessionInput) GetText() *TextInput {
	if x, ok := x.GetInput().(*SessionInput_Text); ok {
		return x.Text
	}
	return nil
}

func (x *SessionInput) GetAsr() *ASRResult {
	if x, ok := x.GetInput().(*SessionInput_Asr); ok {
		return x.Asr
	}
	return nil
}

func (x *SessionInput) GetCmd() *CommandResult {
	if x, ok := x.GetInput().(*SessionInput_Cmd); ok {
		return x.Cmd
	}
	return nil
}

func (x *SessionInput) GetStory() *SetStory {
	if x, ok := x.GetInput().(*SessionInput_Story); ok {
		return x.Story
	}
	return nil
}

type isSessionInput_Input interface {
	isSessionInput_Input()
}

type SessionInput_Text struct {
	// Process the user supplied text.
	Text *TextInput `protobuf:"bytes,2,opt,name=text,proto3,oneof"`
}

type SessionInput_Asr struct {
	// Process an ASR result.
	Asr *ASRResult `protobuf:"bytes,3,opt,name=asr,proto3,oneof"`
}

type SessionInput_Cmd struct {
	// Process the result of a completed command.
	Cmd *CommandResult `protobuf:"bytes,4,opt,name=cmd,proto3,oneof"`
}

type SessionInput_Story struct {
	// Change the current session state.
	Story *SetStory `protobuf:"bytes,5,opt,name=story,proto3,oneof"`
}

func (*SessionInput_Text) isSessionInput_Input() {}

func (*SessionInput_Asr) isSessionInput_Input() {}

func (*SessionInput_Cmd) isSessionInput_Input() {}

func (*SessionInput_Story) isSessionInput_Input() {}

// A token that represents a single Diatheke session and its
// current state.
type TokenData struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// Session ID, useful for correlating logging between a
	// client and the server.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Additional data supplied by the client app, which will
	// be logged with other session info by the server.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (x *TokenData) Reset() {
	*x = TokenData{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TokenData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenData) ProtoMessage() {}

func (x *TokenData) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenData.ProtoReflect.Descriptor instead.
func (*TokenData) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{4}
}

func (x *TokenData) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *TokenData) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TokenData) GetMetadata() string {
	if x != nil {
		return x.Metadata
	}
	return ""
}

// Used to create a new session.
type SessionStart struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Specifies the Diatheke model ID to use for the session.
	ModelId string `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	// Specifies a custom wakeword to use for this session. The
	// wakeword must be enabled in the Diatheke model for this
	// to have any effect. It will override the default wakeword
	// specified in the model.
	Wakeword string `protobuf:"bytes,2,opt,name=wakeword,proto3" json:"wakeword,omitempty"`
}

func (x *SessionStart) Reset() {
	*x = SessionStart{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SessionStart) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionStart) ProtoMessage() {}

func (x *SessionStart) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionStart.ProtoReflect.Descriptor instead.
func (*SessionStart) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{5}
}

func (x *SessionStart) GetModelId() string {
	if x != nil {
		return x.ModelId
	}
	return ""
}

func (x *SessionStart) GetWakeword() string {
	if x != nil {
		return x.Wakeword
	}
	return ""
}

// User supplied text to send to Diatheke for processing.
type TextInput struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
}

func (x *TextInput) Reset() {
	*x = TextInput{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TextInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextInput) ProtoMessage() {}

func (x *TextInput) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextInput.ProtoReflect.Descriptor instead.
func (*TextInput) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{6}
}

func (x *TextInput) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

// The result of executing a command.
type CommandResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The command ID, as given by the CommandAction
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Output from the command expected by the Diatheke model.
	// For example, this could be the result of a data query.
	OutParameters map[string]string `protobuf:"bytes,2,rep,name=out_parameters,json=outParameters,proto3" json:"out_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If there was an error during execution, indicate it
	// here with a brief message that will be logged by
	// Diatheke.
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *CommandResult) Reset() {
	*x = CommandResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommandResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommandResult) ProtoMessage() {}

func (x *CommandResult) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommandResult.ProtoReflect.Descriptor instead.
func (*CommandResult) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{7}
}

func (x *CommandResult) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CommandResult) GetOutParameters() map[string]string {
	if x != nil {
		return x.OutParameters
	}
	return nil
}

func (x *CommandResult) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Changes the current state of a Diatheke session to run at
// the specified story.
type SetStory struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ID of the story to run, as defined in the
	// Diatheke model.
	StoryId string `protobuf:"bytes,1,opt,name=story_id,json=storyId,proto3" json:"story_id,omitempty"`
	// A list of parameters to set before running the given
	// story. This will replace any parameters currently
	// defined in the session.
	Parameters map[string]string `protobuf:"bytes,2,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *SetStory) Reset() {
	*x = SetStory{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetStory) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStory) ProtoMessage() {}

func (x *SetStory) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStory.ProtoReflect.Descriptor instead.
func (*SetStory) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{8}
}

func (x *SetStory) GetStoryId() string {
	if x != nil {
		return x.StoryId
	}
	return ""
}

func (x *SetStory) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

// The result of updating a session.
type SessionOutput struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The updated session token.
	Token *TokenData `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// The list of actions the client should take next,
	// using the session token returned with this result.
	ActionList []*ActionData `protobuf:"bytes,2,rep,name=action_list,json=actionList,proto3" json:"action_list,omitempty"`
}

func (x *SessionOutput) Reset() {
	*x = SessionOutput{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SessionOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionOutput) ProtoMessage() {}

func (x *SessionOutput) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionOutput.ProtoReflect.Descriptor instead.
func (*SessionOutput) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{9}
}

func (x *SessionOutput) GetToken() *TokenData {
	if x != nil {
		return x.Token
	}
	return nil
}

func (x *SessionOutput) GetActionList() []*ActionData {
	if x != nil {
		return x.ActionList
	}
	return nil
}

// Specifies an action that the client application should take.
type ActionData struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Action:
	//	*ActionData_Input
	//	*ActionData_Command
	//	*ActionData_Reply
	//	*ActionData_Transcribe
	Action isActionData_Action `protobuf_oneof:"action"`
}

func (x *ActionData) Reset() {
	*x = ActionData{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ActionData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActionData) ProtoMessage() {}

func (x *ActionData) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActionData.ProtoReflect.Descriptor instead.
func (*ActionData) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{10}
}

func (m *ActionData) GetAction() isActionData_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (x *ActionData) GetInput() *WaitForUserAction {
	if x, ok := x.GetAction().(*ActionData_Input); ok {
		return x.Input
	}
	return nil
}

func (x *ActionData) GetCommand() *CommandAction {
	if x, ok := x.GetAction().(*ActionData_Command); ok {
		return x.Command
	}
	return nil
}

func (x *ActionData) GetReply() *ReplyAction {
	if x, ok := x.GetAction().(*ActionData_Reply); ok {
		return x.Reply
	}
	return nil
}

func (x *ActionData) GetTranscribe() *TranscribeAction {
	if x, ok := x.GetAction().(*ActionData_Transcribe); ok {
		return x.Transcribe
	}
	return nil
}

type isActionData_Action interface {
	isActionData_Action()
}

type ActionData_Input struct {
	// The user must provide input to Diatheke.
	Input *WaitForUserAction `protobuf:"bytes,1,opt,name=input,proto3,oneof"`
}

type ActionData_Command struct {
	// The client app must execute the specified command.
	Command *CommandAction `protobuf:"bytes,2,opt,name=command,proto3,oneof"`
}

type ActionData_Reply struct {
	// The client app should provide the reply to the user.
	Reply *ReplyAction `protobuf:"bytes,3,opt,name=reply,proto3,oneof"`
}

type ActionData_Transcribe struct {
	// The client app should transcribe user input.
	Transcribe *TranscribeAction `protobuf:"bytes,4,opt,name=transcribe,proto3,oneof"`
}

func (*ActionData_Input) isActionData_Action() {}

func (*ActionData_Command) isActionData_Action() {}

func (*ActionData_Reply) isActionData_Action() {}

func (*ActionData_Transcribe) isActionData_Action() {}

// This action indicates that Diatheke is expecting user input.
type WaitForUserAction struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// True if the next user input must begin with a wake-word.
	RequiresWakeWord bool `protobuf:"varint,1,opt,name=requires_wake_word,json=requiresWakeWord,proto3" json:"requires_wake_word,omitempty"`
	// True if the input is required immediately (i.e., in
	// response to a question Diatheke asked the user). When
	// false, the client should be allowed to wait indefinitely
	// for the user to provide input.
	Immediate bool `protobuf:"varint,2,opt,name=immediate,proto3" json:"immediate,omitempty"`
}

func (x *WaitForUserAction) Reset() {
	*x = WaitForUserAction{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WaitForUserAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WaitForUserAction) ProtoMessage() {}

func (x *WaitForUserAction) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WaitForUserAction.ProtoReflect.Descriptor instead.
func (*WaitForUserAction) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{11}
}

func (x *WaitForUserAction) GetRequiresWakeWord() bool {
	if x != nil {
		return x.RequiresWakeWord
	}
	return false
}

func (x *WaitForUserAction) GetImmediate() bool {
	if x != nil {
		return x.Immediate
	}
	return false
}

// This action indicates that the client application should
// execute a command.
type CommandAction struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ID of the command to execute, as defined in the
	// Diatheke model.
	Id              string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	InputParameters map[string]string `protobuf:"bytes,2,rep,name=input_parameters,json=inputParameters,proto3" json:"input_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *CommandAction) Reset() {
	*x = CommandAction{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommandAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommandAction) ProtoMessage() {}

func (x *CommandAction) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommandAction.ProtoReflect.Descriptor instead.
func (*CommandAction) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{12}
}

func (x *CommandAction) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CommandAction) GetInputParameters() map[string]string {
	if x != nil {
		return x.InputParameters
	}
	return nil
}

// This action indicates that the client application should
// give the provided text to the user. This action may also
// be used to synthesize speech with the StreamTTS method.
type ReplyAction struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Text of the reply
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// TTS model to use with the TTSReply method
	LunaModel string `protobuf:"bytes,2,opt,name=luna_model,json=lunaModel,proto3" json:"luna_model,omitempty"`
}

func (x *ReplyAction) Reset() {
	*x = ReplyAction{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReplyAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplyAction) ProtoMessage() {}

func (x *ReplyAction) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplyAction.ProtoReflect.Descriptor instead.
func (*ReplyAction) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{13}
}

func (x *ReplyAction) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *ReplyAction) GetLunaModel() string {
	if x != nil {
		return x.LunaModel
	}
	return ""
}

// This action indicates that the client application should
// transcribe the user's input.
type TranscribeAction struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ID of the transcribe action, which is useful to
	// differentiate separate transcription tasks within a
	// single sesssion.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The ASR model to use for transcription.
	CubicModelId string `protobuf:"bytes,2,opt,name=cubic_model_id,json=cubicModelId,proto3" json:"cubic_model_id,omitempty"`
	// The Diatheke model where this transcribe action is
	// defined. If empty, the server will not be able to
	// automatically close the transcribe stream based on
	// conditions defined in the Diatheke model. In that
	// case, the stream must be closed by the client
	// application.
	DiathekeModelId string `protobuf:"bytes,3,opt,name=diatheke_model_id,json=diathekeModelId,proto3" json:"diatheke_model_id,omitempty"`
}

func (x *TranscribeAction) Reset() {
	*x = TranscribeAction{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TranscribeAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscribeAction) ProtoMessage() {}

func (x *TranscribeAction) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscribeAction.ProtoReflect.Descriptor instead.
func (*TranscribeAction) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{14}
}

func (x *TranscribeAction) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TranscribeAction) GetCubicModelId() string {
	if x != nil {
		return x.CubicModelId
	}
	return ""
}

func (x *TranscribeAction) GetDiathekeModelId() string {
	if x != nil {
		return x.DiathekeModelId
	}
	return ""
}

// Data to send to the ASR stream. The first message on the
// stream must be the session token followed by audio data.
type ASRInput struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Data:
	//	*ASRInput_Token
	//	*ASRInput_Audio
	Data isASRInput_Data `protobuf_oneof:"data"`
}

func (x *ASRInput) Reset() {
	*x = ASRInput{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ASRInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ASRInput) ProtoMessage() {}

func (x *ASRInput) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ASRInput.ProtoReflect.Descriptor instead.
func (*ASRInput) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{15}
}

func (m *ASRInput) GetData() isASRInput_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (x *ASRInput) GetToken() *TokenData {
	if x, ok := x.GetData().(*ASRInput_Token); ok {
		return x.Token
	}
	return nil
}

func (x *ASRInput) GetAudio() []byte {
	if x, ok := x.GetData().(*ASRInput_Audio); ok {
		return x.Audio
	}
	return nil
}

type isASRInput_Data interface {
	isASRInput_Data()
}

type ASRInput_Token struct {
	// Session data, used to determine the correct Cubic
	// model to use for ASR, with other contextual
	// information.
	Token *TokenData `protobuf:"bytes,1,opt,name=token,proto3,oneof"`
}

type ASRInput_Audio struct {
	// Audio data to transcribe.
	Audio []byte `protobuf:"bytes,2,opt,name=audio,proto3,oneof"`
}

func (*ASRInput_Token) isASRInput_Data() {}

func (*ASRInput_Audio) isASRInput_Data() {}

// The result from the ASR stream, sent after the ASR engine
// has endpointed or the stream was closed by the client.
type ASRResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The transcription.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// Confidence estimate between 0 and 1. A higher number
	// represents a higher likelihood of the output being
	// correct.
	Confidence float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// True if a timeout was defined for the session's current
	// input state in the Diatheke model, and the timeout
	// expired before getting a transcription. This timeout
	// refers to the amount of time a user has to verbally
	// respond to Diatheke after the ASR stream has been
	// created, and should not be confused with a network
	// connection timeout.
	TimedOut bool `protobuf:"varint,3,opt,name=timedOut,proto3" json:"timedOut,omitempty"`
}

func (x *ASRResult) Reset() {
	*x = ASRResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ASRResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ASRResult) ProtoMessage() {}

func (x *ASRResult) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ASRResult.ProtoReflect.Descriptor instead.
func (*ASRResult) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{16}
}

func (x *ASRResult) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *ASRResult) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *ASRResult) GetTimedOut() bool {
	if x != nil {
		return x.TimedOut
	}
	return false
}

// Contains synthesized speech audio. The specific encoding
// is defined in the server config file.
type TTSAudio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Audio []byte `protobuf:"bytes,1,opt,name=audio,proto3" json:"audio,omitempty"`
}

func (x *TTSAudio) Reset() {
	*x = TTSAudio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TTSAudio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TTSAudio) ProtoMessage() {}

func (x *TTSAudio) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TTSAudio.ProtoReflect.Descriptor instead.
func (*TTSAudio) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{17}
}

func (x *TTSAudio) GetAudio() []byte {
	if x != nil {
		return x.Audio
	}
	return nil
}

// Data to send to the Transcribe stream. The first message on
// the stream must be a TranscribeAction, followed by audio data.
type TranscribeInput struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Data:
	//	*TranscribeInput_Action
	//	*TranscribeInput_Audio
	Data isTranscribeInput_Data `protobuf_oneof:"data"`
}

func (x *TranscribeInput) Reset() {
	*x = TranscribeInput{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TranscribeInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscribeInput) ProtoMessage() {}

func (x *TranscribeInput) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscribeInput.ProtoReflect.Descriptor instead.
func (*TranscribeInput) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{18}
}

func (m *TranscribeInput) GetData() isTranscribeInput_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (x *TranscribeInput) GetAction() *TranscribeAction {
	if x, ok := x.GetData().(*TranscribeInput_Action); ok {
		return x.Action
	}
	return nil
}

func (x *TranscribeInput) GetAudio() []byte {
	if x, ok := x.GetData().(*TranscribeInput_Audio); ok {
		return x.Audio
	}
	return nil
}

type isTranscribeInput_Data interface {
	isTranscribeInput_Data()
}

type TranscribeInput_Action struct {
	// Action defining the transcribe configuration.
	Action *TranscribeAction `protobuf:"bytes,1,opt,name=action,proto3,oneof"`
}

type TranscribeInput_Audio struct {
	// Audio data to transcribe.
	Audio []byte `protobuf:"bytes,2,opt,name=audio,proto3,oneof"`
}

func (*TranscribeInput_Action) isTranscribeInput_Data() {}

func (*TranscribeInput_Audio) isTranscribeInput_Data() {}

// The result from the Transcribe stream. Usually, many partial
// (or intermediate) transcriptions will be sent until the final
// transcription is ready for every utterance processed.
type TranscribeResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The transcription.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// Confidence estimate between 0 and 1. A higher number
	// represents a higher likelihood of the transcription
	// being correct.
	Confidence float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// True if this is a partial result, in which case the
	// text of the transcription for the current utterance
	// being processed is allowed to change in future results.
	// When false, this represents the final transcription for
	// an utterance, which will not change with further audio
	// input. It is sent when the ASR has endpointed. After the
	// final transcription is sent, any additional results sent
	// on the Transcribe stream belong to the next utterance.
	IsPartial bool `protobuf:"varint,3,opt,name=is_partial,json=isPartial,proto3" json:"is_partial,omitempty"`
}

func (x *TranscribeResult) Reset() {
	*x = TranscribeResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TranscribeResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscribeResult) ProtoMessage() {}

func (x *TranscribeResult) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscribeResult.ProtoReflect.Descriptor instead.
func (*TranscribeResult) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{19}
}

func (x *TranscribeResult) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *TranscribeResult) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *TranscribeResult) GetIsPartial() bool {
	if x != nil {
		return x.IsPartial
	}
	return false
}

type Empty struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() {
	*x = Empty{}
	if protoimpl.UnsafeEnabled {
		mi := &file_diatheke_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Empty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Empty) ProtoMessage() {}

func (x *Empty) ProtoReflect() protoreflect.Message {
	mi := &file_diatheke_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) {
	return file_diatheke_proto_rawDescGZIP(), []int{20}
}

var File_diatheke_proto protoreflect.FileDescriptor

var file_diatheke_proto_rawDesc = []byte{
	0x0a, 0x0e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x15, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64,
	0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x22, 0x6f, 0x0a, 0x0f, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x69,
	0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x64, 0x69,
	0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x68, 0x6f, 0x73, 0x75, 0x6e,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x63, 0x68, 0x6f, 0x73, 0x75, 0x6e, 0x12, 0x14,
	0x0a, 0x05, 0x63, 0x75, 0x62, 0x69, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x63,
	0x75, 0x62, 0x69, 0x63, 0x12, 0x12, 0x0a, 0x04, 0x6c, 0x75, 0x6e, 0x61, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x6c, 0x75, 0x6e, 0x61, 0x22, 0x4e, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74,
	0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38,
	0x0a, 0x06, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20,
	0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69,
	0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x06, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x73, 0x22, 0x9b, 0x01, 0x0a, 0x09, 0x4d, 0x6f, 0x64,
	0x65, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x12, 0x26, 0x0a, 0x0f, 0x61, 0x73, 0x72, 0x5f, 0x73, 0x61,
	0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x0d, 0x61, 0x73, 0x72, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x61, 0x74, 0x65, 0x12, 0x26,
	0x0a, 0x0f, 0x74, 0x74, 0x73, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x72, 0x61, 0x74,
	0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x74, 0x74, 0x73, 0x53, 0x61, 0x6d, 0x70,
	0x6c, 0x65, 0x52, 0x61, 0x74, 0x65, 0x22, 0xb0, 0x02, 0x0a, 0x0c, 0x53, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x36, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73,
	0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x54,
	0x6f, 0x6b, 0x65, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
	0x36, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e,
	0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61,
	0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x48,
	0x00, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x12, 0x34, 0x0a, 0x03, 0x61, 0x73, 0x72, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65,
	0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x41, 0x53, 0x52,
	0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x48, 0x00, 0x52, 0x03, 0x61, 0x73, 0x72, 0x12, 0x38, 0x0a,
	0x03, 0x63, 0x6d, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x63, 0x6f, 0x62,
	0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65,
	0x6b, 0x65, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74,
	0x48, 0x00, 0x52, 0x03, 0x63, 0x6d, 0x64, 0x12, 0x37, 0x0a, 0x05, 0x73, 0x74, 0x6f, 0x72, 0x79,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73,
	0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x53,
	0x65, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x79, 0x48, 0x00, 0x52, 0x05, 0x73, 0x74, 0x6f, 0x72, 0x79,
	0x42, 0x07, 0x0a, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x22, 0x4b, 0x0a, 0x09, 0x54, 0x6f, 0x6b,
	0x65, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x22, 0x45, 0x0a, 0x0c, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f,
	0x6e, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x49,
	0x64, 0x12, 0x1a, 0x0a, 0x08, 0x77, 0x61, 0x6b, 0x65, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x77, 0x61, 0x6b, 0x65, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x1f, 0x0a,
	0x09, 0x54, 0x65, 0x78, 0x74, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65,
	0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x22, 0xd7,
	0x01, 0x0a, 0x0d, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x5e, 0x0a, 0x0e, 0x6f, 0x75, 0x74, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c,
	0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65,
	0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x2e, 0x4f,
	0x75, 0x74, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72,
	0x79, 0x52, 0x0d, 0x6f, 0x75, 0x74, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
	0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x1a, 0x40, 0x0a, 0x12, 0x4f, 0x75, 0x74, 0x50, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
	0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xb5, 0x01, 0x0a, 0x08, 0x53, 0x65, 0x74,
	0x53, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x19, 0x0a, 0x08, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x49, 0x64,
	0x12, 0x4f, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65,
	0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x53, 0x65, 0x74,
	0x53, 0x74, 0x6f, 0x72, 0x79, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
	0x73, 0x1a, 0x3d, 0x0a, 0x0f, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
	0x22, 0x8b, 0x01, 0x0a, 0x0d, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x4f, 0x75, 0x74, 0x70,
	0x75, 0x74, 0x12, 0x36, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x44,
	0x61, 0x74, 0x61, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x42, 0x0a, 0x0b, 0x61, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x21, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64,
	0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61,
	0x74, 0x61, 0x52, 0x0a, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4c, 0x69, 0x73, 0x74, 0x22, 0xa1,
	0x02, 0x0a, 0x0a, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x12, 0x40, 0x0a,
	0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74,
	0x68, 0x65, 0x6b, 0x65, 0x2e, 0x57, 0x61, 0x69, 0x74, 0x46, 0x6f, 0x72, 0x55, 0x73, 0x65, 0x72,
	0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x12,
	0x40, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x24, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e,
	0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
	0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
	0x64, 0x12, 0x3a, 0x0a, 0x05, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x22, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e,
	0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x41, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x05, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x49, 0x0a,
	0x0a, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x27, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63,
	0x72, 0x69, 0x62, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x0a, 0x74, 0x72,
	0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x42, 0x08, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x22, 0x5f, 0x0a, 0x11, 0x57, 0x61, 0x69, 0x74, 0x46, 0x6f, 0x72, 0x55, 0x73, 0x65,
	0x72, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2c, 0x0a, 0x12, 0x72, 0x65, 0x71, 0x75, 0x69,
	0x72, 0x65, 0x73, 0x5f, 0x77, 0x61, 0x6b, 0x65, 0x5f, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x10, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x73, 0x57, 0x61, 0x6b,
	0x65, 0x57, 0x6f, 0x72, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x6d, 0x6d, 0x65, 0x64, 0x69, 0x61,
	0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x6d, 0x6d, 0x65, 0x64, 0x69,
	0x61, 0x74, 0x65, 0x22, 0xc9, 0x01, 0x0a, 0x0d, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x41,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x64, 0x0a, 0x10, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x5f, 0x70,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x39, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64,
	0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x41,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0f, 0x69, 0x6e, 0x70, 0x75,
	0x74, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x42, 0x0a, 0x14, 0x49,
	0x6e, 0x70, 0x75, 0x74, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22,
	0x40, 0x0a, 0x0b, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12,
	0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65,
	0x78, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x6c, 0x75, 0x6e, 0x61, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6c, 0x75, 0x6e, 0x61, 0x4d, 0x6f, 0x64, 0x65,
	0x6c, 0x22, 0x74, 0x0a, 0x10, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x41,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x24, 0x0a, 0x0e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x5f, 0x6d,
	0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63,
	0x75, 0x62, 0x69, 0x63, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x49, 0x64, 0x12, 0x2a, 0x0a, 0x11, 0x64,
	0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x69, 0x64,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65,
	0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x49, 0x64, 0x22, 0x64, 0x0a, 0x08, 0x41, 0x53, 0x52, 0x49, 0x6e,
	0x70, 0x75, 0x74, 0x12, 0x38, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
	0x44, 0x61, 0x74, 0x61, 0x48, 0x00, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x16, 0x0a,
	0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x05,
	0x61, 0x75, 0x64, 0x69, 0x6f, 0x42, 0x06, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x22, 0x5b, 0x0a,
	0x09, 0x41, 0x53, 0x52, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65,
	0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x12, 0x1e,
	0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x1a,
	0x0a, 0x08, 0x74, 0x69, 0x6d, 0x65, 0x64, 0x4f, 0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x08, 0x74, 0x69, 0x6d, 0x65, 0x64, 0x4f, 0x75, 0x74, 0x22, 0x20, 0x0a, 0x08, 0x54, 0x54,
	0x53, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x22, 0x74, 0x0a, 0x0f,
	0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x12,
	0x41, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x27, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64,
	0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69,
	0x62, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0c, 0x48, 0x00, 0x52, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x42, 0x06, 0x0a, 0x04, 0x64, 0x61,
	0x74, 0x61, 0x22, 0x65, 0x0a, 0x10, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
	0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f,
	0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0a,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73,
	0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09,
	0x69, 0x73, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x32, 0xd4, 0x05, 0x0a, 0x08, 0x44, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x12,
	0x51, 0x0a, 0x07, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x2e, 0x63, 0x6f, 0x62,
	0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65,
	0x6b, 0x65, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x26, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c,
	0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65,
	0x2e, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x57, 0x0a, 0x0a, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x73,
	0x12, 0x1c, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e,
	0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x29,
	0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69,
	0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x6c,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5c, 0x0a, 0x0d, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74,
	0x68, 0x65, 0x6b, 0x65, 0x2e, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x72,
	0x74, 0x1a, 0x24, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f,
	0x6e, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x22, 0x00, 0x12, 0x51, 0x0a, 0x0d, 0x44, 0x65, 0x6c,
	0x65, 0x74, 0x65, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x2e, 0x63, 0x6f, 0x62,
	0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65,
	0x6b, 0x65, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x1a, 0x1c, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74,
	0x68, 0x65, 0x6b, 0x65, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x5c, 0x0a, 0x0d,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x2e,
	0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61,
	0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70,
	0x75, 0x74, 0x1a, 0x24, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x53, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x22, 0x00, 0x12, 0x52, 0x0a, 0x09, 0x53, 0x74,
	0x72, 0x65, 0x61, 0x6d, 0x41, 0x53, 0x52, 0x12, 0x1f, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74,
	0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e,
	0x41, 0x53, 0x52, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x1a, 0x20, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c,
	0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65,
	0x2e, 0x41, 0x53, 0x52, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x22, 0x00, 0x28, 0x01, 0x12, 0x54,
	0x0a, 0x09, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x54, 0x54, 0x53, 0x12, 0x22, 0x2e, 0x63, 0x6f,
	0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68,
	0x65, 0x6b, 0x65, 0x2e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x1a,
	0x1f, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64,
	0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x54, 0x54, 0x53, 0x41, 0x75, 0x64, 0x69, 0x6f,
	0x22, 0x00, 0x30, 0x01, 0x12, 0x63, 0x0a, 0x0a, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69,
	0x62, 0x65, 0x12, 0x26, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73,
	0x63, 0x72, 0x69, 0x62, 0x65, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x1a, 0x27, 0x2e, 0x63, 0x6f, 0x62,
	0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65,
	0x6b, 0x65, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x52, 0x65, 0x73,
	0x75, 0x6c, 0x74, 0x22, 0x00, 0x28, 0x01, 0x30, 0x01, 0x42, 0x29, 0x0a, 0x19, 0x63, 0x6f, 0x6d,
	0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x64, 0x69,
	0x61, 0x74, 0x68, 0x65, 0x6b, 0x65, 0x5a, 0x0c, 0x2e, 0x3b, 0x64, 0x69, 0x61, 0x74, 0x68, 0x65,
	0x6b, 0x65, 0x70, 0x62, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_diatheke_proto_rawDescOnce sync.Once
	file_diatheke_proto_rawDescData = file_diatheke_proto_rawDesc
)

func file_diatheke_proto_rawDescGZIP() []byte {
	file_diatheke_proto_rawDescOnce.Do(func() {
		file_diatheke_proto_rawDescData = protoimpl.X.CompressGZIP(file_diatheke_proto_rawDescData)
	})
	return file_diatheke_proto_rawDescData
}

var file_diatheke_proto_msgTypes = make([]protoimpl.MessageInfo, 24)
var file_diatheke_proto_goTypes = []interface{}{
	(*VersionResponse)(nil),    // 0: cobaltspeech.diatheke.VersionResponse
	(*ListModelsResponse)(nil), // 1: cobaltspeech.diatheke.ListModelsResponse
	(*ModelInfo)(nil),          // 2: cobaltspeech.diatheke.ModelInfo
	(*SessionInput)(nil),       // 3: cobaltspeech.diatheke.SessionInput
	(*TokenData)(nil),          // 4: cobaltspeech.diatheke.TokenData
	(*SessionStart)(nil),       // 5: cobaltspeech.diatheke.SessionStart
	(*TextInput)(nil),          // 6: cobaltspeech.diatheke.TextInput
	(*CommandResult)(nil),      // 7: cobaltspeech.diatheke.CommandResult
	(*SetStory)(nil),           // 8: cobaltspeech.diatheke.SetStory
	(*SessionOutput)(nil),      // 9: cobaltspeech.diatheke.SessionOutput
	(*ActionData)(nil),         // 10: cobaltspeech.diatheke.ActionData
	(*WaitForUserAction)(nil),  // 11: cobaltspeech.diatheke.WaitForUserAction
	(*CommandAction)(nil),      // 12: cobaltspeech.diatheke.CommandAction
	(*ReplyAction)(nil),        // 13: cobaltspeech.diatheke.ReplyAction
	(*TranscribeAction)(nil),   // 14: cobaltspeech.diatheke.TranscribeAction
	(*ASRInput)(nil),           // 15: cobaltspeech.diatheke.ASRInput
	(*ASRResult)(nil),          // 16: cobaltspeech.diatheke.ASRResult
	(*TTSAudio)(nil),           // 17: cobaltspeech.diatheke.TTSAudio
	(*TranscribeInput)(nil),    // 18: cobaltspeech.diatheke.TranscribeInput
	(*TranscribeResult)(nil),   // 19: cobaltspeech.diatheke.TranscribeResult
	(*Empty)(nil),              // 20: cobaltspeech.diatheke.Empty
	nil,                        // 21: cobaltspeech.diatheke.CommandResult.OutParametersEntry
	nil,                        // 22: cobaltspeech.diatheke.SetStory.ParametersEntry
	nil,                        // 23: cobaltspeech.diatheke.CommandAction.InputParametersEntry
}
var file_diatheke_proto_depIdxs = []int32{
	2,  // 0: cobaltspeech.diatheke.ListModelsResponse.models:type_name -> cobaltspeech.diatheke.ModelInfo
	4,  // 1: cobaltspeech.diatheke.SessionInput.token:type_name -> cobaltspeech.diatheke.TokenData
	6,  // 2: cobaltspeech.diatheke.SessionInput.text:type_name -> cobaltspeech.diatheke.TextInput
	16, // 3: cobaltspeech.diatheke.SessionInput.asr:type_name -> cobaltspeech.diatheke.ASRResult
	7,  // 4: cobaltspeech.diatheke.SessionInput.cmd:type_name -> cobaltspeech.diatheke.CommandResult
	8,  // 5: cobaltspeech.diatheke.SessionInput.story:type_name -> cobaltspeech.diatheke.SetStory
	21, // 6: cobaltspeech.diatheke.CommandResult.out_parameters:type_name -> cobaltspeech.diatheke.CommandResult.OutParametersEntry
	22, // 7: cobaltspeech.diatheke.SetStory.parameters:type_name -> cobaltspeech.diatheke.SetStory.ParametersEntry
	4,  // 8: cobaltspeech.diatheke.SessionOutput.token:type_name -> cobaltspeech.diatheke.TokenData
	10, // 9: cobaltspeech.diatheke.SessionOutput.action_list:type_name -> cobaltspeech.diatheke.ActionData
	11, // 10: cobaltspeech.diatheke.ActionData.input:type_name -> cobaltspeech.diatheke.WaitForUserAction
	12, // 11: cobaltspeech.diatheke.ActionData.command:type_name -> cobaltspeech.diatheke.CommandAction
	13, // 12: cobaltspeech.diatheke.ActionData.reply:type_name -> cobaltspeech.diatheke.ReplyAction
	14, // 13: cobaltspeech.diatheke.ActionData.transcribe:type_name -> cobaltspeech.diatheke.TranscribeAction
	23, // 14: cobaltspeech.diatheke.CommandAction.input_parameters:type_name -> cobaltspeech.diatheke.CommandAction.InputParametersEntry
	4,  // 15: cobaltspeech.diatheke.ASRInput.token:type_name -> cobaltspeech.diatheke.TokenData
	14, // 16: cobaltspeech.diatheke.TranscribeInput.action:type_name -> cobaltspeech.diatheke.TranscribeAction
	20, // 17: cobaltspeech.diatheke.Diatheke.Version:input_type -> cobaltspeech.diatheke.Empty
	20, // 18: cobaltspeech.diatheke.Diatheke.ListModels:input_type -> cobaltspeech.diatheke.Empty
	5,  // 19: cobaltspeech.diatheke.Diatheke.CreateSession:input_type -> cobaltspeech.diatheke.SessionStart
	4,  // 20: cobaltspeech.diatheke.Diatheke.DeleteSession:input_type -> cobaltspeech.diatheke.TokenData
	3,  // 21: cobaltspeech.diatheke.Diatheke.UpdateSession:input_type -> cobaltspeech.diatheke.SessionInput
	15, // 22: cobaltspeech.diatheke.Diatheke.StreamASR:input_type -> cobaltspeech.diatheke.ASRInput
	13, // 23: cobaltspeech.diatheke.Diatheke.StreamTTS:input_type -> cobaltspeech.diatheke.ReplyAction
	18, // 24: cobaltspeech.diatheke.Diatheke.Transcribe:input_type -> cobaltspeech.diatheke.TranscribeInput
	0,  // 25: cobaltspeech.diatheke.Diatheke.Version:output_type -> cobaltspeech.diatheke.VersionResponse
	1,  // 26: cobaltspeech.diatheke.Diatheke.ListModels:output_type -> cobaltspeech.diatheke.ListModelsResponse
	9,  // 27: cobaltspeech.diatheke.Diatheke.CreateSession:output_type -> cobaltspeech.diatheke.SessionOutput
	20, // 28: cobaltspeech.diatheke.Diatheke.DeleteSession:output_type -> cobaltspeech.diatheke.Empty
	9,  // 29: cobaltspeech.diatheke.Diatheke.UpdateSession:output_type -> cobaltspeech.diatheke.SessionOutput
	16, // 30: cobaltspeech.diatheke.Diatheke.StreamASR:output_type -> cobaltspeech.diatheke.ASRResult
	17, // 31: cobaltspeech.diatheke.Diatheke.StreamTTS:output_type -> cobaltspeech.diatheke.TTSAudio
	19, // 32: cobaltspeech.diatheke.Diatheke.Transcribe:output_type -> cobaltspeech.diatheke.TranscribeResult
	25, // [25:33] is the sub-list for method output_type
	17, // [17:25] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_diatheke_proto_init() }
func file_diatheke_proto_init() {
	if File_diatheke_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_diatheke_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VersionResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListModelsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ModelInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SessionInput); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TokenData); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SessionStart); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TextInput); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommandResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetStory); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SessionOutput); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ActionData); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WaitForUserAction); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommandAction); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReplyAction); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TranscribeAction); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ASRInput); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ASRResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TTSAudio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TranscribeInput); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TranscribeResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_diatheke_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Empty); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_diatheke_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*SessionInput_Text)(nil),
		(*SessionInput_Asr)(nil),
		(*SessionInput_Cmd)(nil),
		(*SessionInput_Story)(nil),
	}
	file_diatheke_proto_msgTypes[10].OneofWrappers = []interface{}{
		(*ActionData_Input)(nil),
		(*ActionData_Command)(nil),
		(*ActionData_Reply)(nil),
		(*ActionData_Transcribe)(nil),
	}
	file_diatheke_proto_msgTypes[15].OneofWrappers = []interface{}{
		(*ASRInput_Token)(nil),
		(*ASRInput_Audio)(nil),
	}
	file_diatheke_proto_msgTypes[18].OneofWrappers = []interface{}{
		(*TranscribeInput_Action)(nil),
		(*TranscribeInput_Audio)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_diatheke_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   24,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_diatheke_proto_goTypes,
		DependencyIndexes: file_diatheke_proto_depIdxs,
		MessageInfos:      file_diatheke_proto_msgTypes,
	}.Build()
	File_diatheke_proto = out.File
	file_diatheke_proto_rawDesc = nil
	file_diatheke_proto_goTypes = nil
	file_diatheke_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// DiathekeClient is the client API for Diatheke service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DiathekeClient interface {
	// Returns version information from the server.
	Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	// ListModels returns information about the Diatheke models
	// the server can access.
	ListModels(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListModelsResponse, error)
	// Create a new Diatheke session. Also returns a list of
	// actions to take next.
	CreateSession(ctx context.Context, in *SessionStart, opts ...grpc.CallOption) (*SessionOutput, error)
	// Delete the session. Behavior is undefined if the given
	// TokenData is used again after this function is called.
	DeleteSession(ctx context.Context, in *TokenData, opts ...grpc.CallOption) (*Empty, error)
	// Process input for a session and get an updated session with
	// a list of actions to take next. This is the only method
	// that modifies the Diatheke session state.
	UpdateSession(ctx context.Context, in *SessionInput, opts ...grpc.CallOption) (*SessionOutput, error)
	// Create an ASR stream. A result is returned when the
	// stream is closed by the client (which forces the ASR to
	// endpoint), or when a transcript becomes available on its
	// own, in which case the stream is closed by the server.
	// The ASR result may be used in the UpdateSession method.
	//
	// If the session has a wakeword enabled, and the client
	// application is using Diatheke and Cubic to handle the
	// wakeword processing, this method will not return a
	// result until the wakeword condition has been satisfied.
	// Utterances without the required wakeword will be
	// discarded and no transcription will be returned.
	StreamASR(ctx context.Context, opts ...grpc.CallOption) (Diatheke_StreamASRClient, error)
	// Create a TTS stream to receive audio for the given reply.
	// The stream will close when TTS is finished. The client
	// may also close the stream early to cancel the speech
	// synthesis.
	StreamTTS(ctx context.Context, in *ReplyAction, opts ...grpc.CallOption) (Diatheke_StreamTTSClient, error)
	// Create an ASR stream for transcription. Unlike StreamASR,
	// Transcribe does not listen for a wakeword. This method
	// returns a bi-directional stream, and its intended use is
	// for situations where a user may say anything at all, whether
	// it is short or long, and the application wants to save the
	// transcript (e.g., take a note, send a message).
	//
	// The first message sent to the server must include the
	// Cubic model ID, with remaining messages sending audio data.
	// Messages received from the server will include the current
	// best partial transcription until the full transcription is
	// ready. The stream ends when either the client application
	// closes it, a predefined duration of silence (non-speech)
	// occurs, or the end-transcription intent is recognized.
	Transcribe(ctx context.Context, opts ...grpc.CallOption) (Diatheke_TranscribeClient, error)
}

type diathekeClient struct {
	cc grpc.ClientConnInterface
}

func NewDiathekeClient(cc grpc.ClientConnInterface) DiathekeClient {
	return &diathekeClient{cc}
}

func (c *diathekeClient) Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) ListModels(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListModelsResponse, error) {
	out := new(ListModelsResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/ListModels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) CreateSession(ctx context.Context, in *SessionStart, opts ...grpc.CallOption) (*SessionOutput, error) {
	out := new(SessionOutput)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/CreateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) DeleteSession(ctx context.Context, in *TokenData, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/DeleteSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) UpdateSession(ctx context.Context, in *SessionInput, opts ...grpc.CallOption) (*SessionOutput, error) {
	out := new(SessionOutput)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/UpdateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) StreamASR(ctx context.Context, opts ...grpc.CallOption) (Diatheke_StreamASRClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[0], "/cobaltspeech.diatheke.Diatheke/StreamASR", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeStreamASRClient{stream}
	return x, nil
}

type Diatheke_StreamASRClient interface {
	Send(*ASRInput) error
	CloseAndRecv() (*ASRResult, error)
	grpc.ClientStream
}

type diathekeStreamASRClient struct {
	grpc.ClientStream
}

func (x *diathekeStreamASRClient) Send(m *ASRInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *diathekeStreamASRClient) CloseAndRecv() (*ASRResult, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ASRResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diathekeClient) StreamTTS(ctx context.Context, in *ReplyAction, opts ...grpc.CallOption) (Diatheke_StreamTTSClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[1], "/cobaltspeech.diatheke.Diatheke/StreamTTS", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeStreamTTSClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Diatheke_StreamTTSClient interface {
	Recv() (*TTSAudio, error)
	grpc.ClientStream
}

type diathekeStreamTTSClient struct {
	grpc.ClientStream
}

func (x *diathekeStreamTTSClient) Recv() (*TTSAudio, error) {
	m := new(TTSAudio)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diathekeClient) Transcribe(ctx context.Context, opts ...grpc.CallOption) (Diatheke_TranscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[2], "/cobaltspeech.diatheke.Diatheke/Transcribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeTranscribeClient{stream}
	return x, nil
}

type Diatheke_TranscribeClient interface {
	Send(*TranscribeInput) error
	Recv() (*TranscribeResult, error)
	grpc.ClientStream
}

type diathekeTranscribeClient struct {
	grpc.ClientStream
}

func (x *diathekeTranscribeClient) Send(m *TranscribeInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *diathekeTranscribeClient) Recv() (*TranscribeResult, error) {
	m := new(TranscribeResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DiathekeServer is the server API for Diatheke service.
type DiathekeServer interface {
	// Returns version information from the server.
	Version(context.Context, *Empty) (*VersionResponse, error)
	// ListModels returns information about the Diatheke models
	// the server can access.
	ListModels(context.Context, *Empty) (*ListModelsResponse, error)
	// Create a new Diatheke session. Also returns a list of
	// actions to take next.
	CreateSession(context.Context, *SessionStart) (*SessionOutput, error)
	// Delete the session. Behavior is undefined if the given
	// TokenData is used again after this function is called.
	DeleteSession(context.Context, *TokenData) (*Empty, error)
	// Process input for a session and get an updated session with
	// a list of actions to take next. This is the only method
	// that modifies the Diatheke session state.
	UpdateSession(context.Context, *SessionInput) (*SessionOutput, error)
	// Create an ASR stream. A result is returned when the
	// stream is closed by the client (which forces the ASR to
	// endpoint), or when a transcript becomes available on its
	// own, in which case the stream is closed by the server.
	// The ASR result may be used in the UpdateSession method.
	//
	// If the session has a wakeword enabled, and the client
	// application is using Diatheke and Cubic to handle the
	// wakeword processing, this method will not return a
	// result until the wakeword condition has been satisfied.
	// Utterances without the required wakeword will be
	// discarded and no transcription will be returned.
	StreamASR(Diatheke_StreamASRServer) error
	// Create a TTS stream to receive audio for the given reply.
	// The stream will close when TTS is finished. The client
	// may also close the stream early to cancel the speech
	// synthesis.
	StreamTTS(*ReplyAction, Diatheke_StreamTTSServer) error
	// Create an ASR stream for transcription. Unlike StreamASR,
	// Transcribe does not listen for a wakeword. This method
	// returns a bi-directional stream, and its intended use is
	// for situations where a user may say anything at all, whether
	// it is short or long, and the application wants to save the
	// transcript (e.g., take a note, send a message).
	//
	// The first message sent to the server must include the
	// Cubic model ID, with remaining messages sending audio data.
	// Messages received from the server will include the current
	// best partial transcription until the full transcription is
	// ready. The stream ends when either the client application
	// closes it, a predefined duration of silence (non-speech)
	// occurs, or the end-transcription intent is recognized.
	Transcribe(Diatheke_TranscribeServer) error
}

// UnimplementedDiathekeServer can be embedded to have forward compatible implementations.
type UnimplementedDiathekeServer struct {
}

func (*UnimplementedDiathekeServer) Version(context.Context, *Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (*UnimplementedDiathekeServer) ListModels(context.Context, *Empty) (*ListModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModels not implemented")
}
func (*UnimplementedDiathekeServer) CreateSession(context.Context, *SessionStart) (*SessionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}
func (*UnimplementedDiathekeServer) DeleteSession(context.Context, *TokenData) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSession not implemented")
}
func (*UnimplementedDiathekeServer) UpdateSession(context.Context, *SessionInput) (*SessionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSession not implemented")
}
func (*UnimplementedDiathekeServer) StreamASR(Diatheke_StreamASRServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamASR not implemented")
}
func (*UnimplementedDiathekeServer) StreamTTS(*ReplyAction, Diatheke_StreamTTSServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamTTS not implemented")
}
func (*UnimplementedDiathekeServer) Transcribe(Diatheke_TranscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Transcribe not implemented")
}

func RegisterDiathekeServer(s *grpc.Server, srv DiathekeServer) {
	s.RegisterService(&_Diatheke_serviceDesc, srv)
}

func _Diatheke_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).Version(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_ListModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).ListModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/ListModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).ListModels(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionStart)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/CreateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).CreateSession(ctx, req.(*SessionStart))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/DeleteSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).DeleteSession(ctx, req.(*TokenData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_UpdateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).UpdateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/UpdateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).UpdateSession(ctx, req.(*SessionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_StreamASR_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DiathekeServer).StreamASR(&diathekeStreamASRServer{stream})
}

type Diatheke_StreamASRServer interface {
	SendAndClose(*ASRResult) error
	Recv() (*ASRInput, error)
	grpc.ServerStream
}

type diathekeStreamASRServer struct {
	grpc.ServerStream
}

func (x *diathekeStreamASRServer) SendAndClose(m *ASRResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *diathekeStreamASRServer) Recv() (*ASRInput, error) {
	m := new(ASRInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Diatheke_StreamTTS_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReplyAction)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiathekeServer).StreamTTS(m, &diathekeStreamTTSServer{stream})
}

type Diatheke_StreamTTSServer interface {
	Send(*TTSAudio) error
	grpc.ServerStream
}

type diathekeStreamTTSServer struct {
	grpc.ServerStream
}

func (x *diathekeStreamTTSServer) Send(m *TTSAudio) error {
	return x.ServerStream.SendMsg(m)
}

func _Diatheke_Transcribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DiathekeServer).Transcribe(&diathekeTranscribeServer{stream})
}

type Diatheke_TranscribeServer interface {
	Send(*TranscribeResult) error
	Recv() (*TranscribeInput, error)
	grpc.ServerStream
}

type diathekeTranscribeServer struct {
	grpc.ServerStream
}

func (x *diathekeTranscribeServer) Send(m *TranscribeResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *diathekeTranscribeServer) Recv() (*TranscribeInput, error) {
	m := new(TranscribeInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Diatheke_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cobaltspeech.diatheke.Diatheke",
	HandlerType: (*DiathekeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Diatheke_Version_Handler,
		},
		{
			MethodName: "ListModels",
			Handler:    _Diatheke_ListModels_Handler,
		},
		{
			MethodName: "CreateSession",
			Handler:    _Diatheke_CreateSession_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _Diatheke_DeleteSession_Handler,
		},
		{
			MethodName: "UpdateSession",
			Handler:    _Diatheke_UpdateSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamASR",
			Handler:       _Diatheke_StreamASR_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamTTS",
			Handler:       _Diatheke_StreamTTS_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Transcribe",
			Handler:       _Diatheke_Transcribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "diatheke.proto",
}
