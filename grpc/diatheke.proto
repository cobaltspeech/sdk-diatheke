// Copyright (2020) Cobalt Speech and Language Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package cobaltspeech.diatheke;

option go_package = "diathekepb";

// Service that implements the Cobalt Diatheke Dialog Management API.
service Diatheke {
  // Queries the Version of the Server.
  rpc Version(Empty) returns (VersionResponse) {}

  // Models will return a list of available versions.  Model values from
  // this list may be used in NewSession calls.
  rpc Models(Empty) returns (ModelsResponse) {}

  // Requests a new session with the given config and returns the session
  // ID, which is required for other rpc methods. After the session is
  // created, StartSession() must be called to begin executing the Diatheke
  // model.
  rpc NewSession(NewSessionRequest) returns (SessionID) {}

  // Begin execution of the model for the given session ID. The session's
  // event stream should be set up prior to calling this function so that
  // the client application can respond to any initialization events that
  // are defined in the session's model.
  rpc StartSession(SessionID) returns (Empty) {}

  // Terminates an existing session and closes any open session streams.
  // It is an error if the SessionEndRequest has an invalid SessionID.
  rpc EndSession(SessionID) returns (Empty) {}

  // Requests a new event stream for the given session. Only one stream
  // per session is allowed.
  rpc SessionEventStream(SessionID) returns (stream DiathekeEvent) {}

  // Notify Diatheke when a command has completed so that it may update
  // the dialog state. The initial command request will come as part of
  // a DiathekeEvent. Client applications should always call this after
  // receiving a command event, or else the session will hang.
  rpc CommandFinished(CommandStatus) returns (Empty) {}

  // Begin an audio input stream for a session. The first message to
  // the server should specify the sessionID, with binary audio data pushed
  // for every subsequent message. As the audio is recognized, Diatheke
  // will respond with appropriate events on the session's event stream.
  // <p>
  // Only one stream per session is allowed. Previous audio streams should
  // always be closed before starting a new one.
  rpc StreamAudioInput(stream AudioInput) returns (Empty) {}

  // Create an audio reply stream for a session. The returned stream
  // will receive replies (as defined in the Diatheke model) from the
  // server as they occur in the conversation. For each reply, the
  // stream will first receive the text to synthesize (defined by the model),
  // followed by one or more messages containing the synthesized audio bytes.
  // The reply will end with a message indicating that TTS for that
  // entry is complete. Only one reply stream per session is allowed.
  // NOTE: The text in the first message of an audio reply is the same that
  //       will be received in the session's event stream.
  rpc StreamAudioReplies(SessionID) returns (stream AudioReply) {}

  // Push text to Diatheke as part of the conversation for a session.
  // Diatheke will respond with an appropriate event on the session's
  // event stream based on whether the given text was recognized as a
  // valid intent or not.
  rpc PushText(PushTextRequest) returns (Empty) {}

  // Change the current story for a running session. This function can
  // be used to implement system intiated alerts or to change the current
  // session state.
  rpc SetStory(StoryRequest) returns (Empty) {}

  // Manually run streaming ASR unrelated to any session by pushing
  // audio data to the server on the audio stream. As transcriptions
  // become available, the server will return them on the ASRResponse
  // stream. The transcriptions may then be used for, e.g., the PushText
  // method. This function is provided as a convenience.
  rpc StreamASR(stream ASRRequest) returns (stream ASRResponse) {}

  // Manually run streaming TTS. The Audio stream will receive
  // binary audio data as it is synthesized and will close automatically
  // when synthesis is complete. This function is provided as a
  // convenience.
  rpc StreamTTS(TTSRequest) returns (stream TTSResponse) {}
}

// The message sent by the server for the `Version` method.
message VersionResponse {
  // Server that manages all of the the other components.
  string server = 1;
}

// The message sent by the server in response to a Models request.
// Returns an array of model names.
message ModelsResponse {
  // Array of models available for use.
  repeated string models = 1;
}

// Request for the NewSession call.
message NewSessionRequest {
  // For applications that have more than one model to use for ASR/NLU.
  // ASR grammar can vary between models, as well as sets of commands.
  // Some applications will only have one model.
  string model = 1;
}

// Simple message that only contains the session ID.
message SessionID {
  // Session ID returned from the NewSession call.
  string session_id = 1;
}

// An event from Diatheke in response to either recognized audio,
// submitted text, or some other transition in the model.
message DiathekeEvent {
  oneof result {
    // Indicates Diatheke found an actionable state in the dialog,
    // and requests the client to perform the given command.
    //
    // Users should always call CommandFinished after receiving
    // this event so that Diatheke can update the dialog state when the
    // command is complete.
    CommandEvent command = 1;

    // An event indicating whether pushed text and audio was recognized by
    // ASR and/or Diatheke.
    RecognizeEvent recognize = 2;

    // The textual reply from Diatheke in the conversation (not to be 
    // confused with the server concepts of request and response). For 
    // example, this could be a question to solicit more information 
    // from the user, a status report, or any other reply defined by 
    // the Diatheke model. The text of this message is also provided in
    // the AudioReply stream (if one is open).
    ReplyEvent reply = 3;

    // Indicates that Diatheke is expecting user input (text or audio).
    InputRequiredEvent input_required = 4;

    // Indicates that Diatheke has returned to the start state of the
    // model.
    AtStartEvent at_start = 5;
  }
}

// A CommandEvent occurs when Diatheke wants the client to execute the
// given command.
message CommandEvent {
  // ID of the command that should be run.  i.e. "COM01" for Command #01.
  string command_id = 1;

  // A generic map of parameters (name, value). The parameters are 
  // defined in the Diatheke model. Depending on the command, these
  // parameters should be sent back with the CommandStatus update.
  map<string, string> parameters = 2;

  // ID to keep track of the dialog state when the command is requested.
  // This field is required in the CommandStatus message so that Diatheke
  // can correctly update the dialog state when CommandFinished is called.
  string command_state_id = 3;
}

// A RecognizeEvent occurs if a session's audio input has a transcription
// available, or if the PushText method was called. In both cases, the
// event will indicate whether the text was recognized as a valid intent
// by the Diatheke model.
message RecognizeEvent
{
  // The pushed text or transcription of audio sent to Diatheke.
  string text = 1;

  // True if the submitted text or audio transcription was recognized by the
  // Diatheke model as a valid intent or entity.
  bool valid_input = 2;
}

// A ReplyEvent occurs when Diatheke has a reply in the conversation (not
// to be confused with the server concepts of request and response). These
// correspond to replies defined in the Diatheke model. For example, it might
// be a prompt for additional information from the user, a status update,
// or a confirmation. ReplyEvents are not generated in response to 
// StreamTTS calls.
message ReplyEvent
{
  // Text of the reply event (defined by the Diatheke model).
  string text = 1;

  // Label of the reply event (defined by the Diatheke model).
  string label = 2;
}

// An InputRequiredEvent occurs when Diatheke is expecting input from
// the user (text or audio).
message InputRequiredEvent {}

// The AtStartEvent is sent when a Diatheke session returns back the
// start state of the model.
message AtStartEvent {}

// The final status of an executed command.
message CommandStatus {
  // session_id should be the same as the status id returned from
  // NewSessionResponse.
  string session_id = 1;

  // ID of the command as given in the RunCommand object.
  string command_id = 2;

  // CommandStatus are the resulting states of a command.
  enum StatusCode {
    // SUCCESS indicates that the command was successfully completed, and the
    // dialog state may now move on to the next state.
    SUCCESS = 0;
    // FAILURE indicates that there was a fatal error running the command.
    // The session will log an error and return to the start state of the
    // model when this status is encountered.
    FAILURE = 1;
  }
  StatusCode return_status = 3;

  // Parameters to return to Diatheke. For example, the map might contain
  // the entry "temperature", which was populated with a value of "30" 
  // after the command finished. Expected parameters are defined by the
  // Diatheke model.
  map<string, string> output_parameters = 4;

  // Set this field with an error message if a fatal error occured while
  // executing the command (return_status == FAILURE).
  string error_message_text = 5;

  // State ID from the original CommandEvent. This field is required for
  // Diatheke to correctly update the dialog state when CommandFinished 
  // is called.
  string command_state_id = 6;
}

// Provides input audio data for StreamAudioInput. The first message
// sent must contain the session ID only. All subsequent messages
// must contain audio data only.
message AudioInput {
  oneof request {
    // Session ID returned from the NewSession call.
    string session_id = 1;

    // Audio data to process. The encoding of the data should match what
    // was specified in the Diatheke server configuration.
    // NOTE: If the audio data is empty, the server may interpret it as
    //       the end of the stream and stop accepting further messages.
    bytes data = 2;
  }
}

// An AudioReply is the verbal and textual reply that Diatheke returns as
// part of a conversation (not to be confused with the server concepts of
// request and response).
message AudioReply {
  // The label defined in the Diatheke model. Identifies which reply
  // in the model this message corresponds to.
  string label = 1;

  oneof output_message {
    // The reply text as defined in the Diatheke model. This is the first
    // message that will be received for an AudioReply. It contains the
    // same text as the corresponding ReplyEvent in the session's event
    // stream.
    string text = 2;

    // The audio data from TTS. There can be any number of these messages
    // for an AudioReply after the first text message and before the final
    // end message. The encoding of the data will match what was specified
    // in the server configuration.
    bytes data = 3;

    // Indicates that TTS has finished streaming audio for the reply. This
    // is the last message that will be received for an AudioReply.
    Empty end = 4;
  }
}

// Request to push text to Diatheke as part of a conversation.
message PushTextRequest {
  // Session ID returned from the NewSession call.
  string session_id = 1;

  // User input. This could be a transcription from manually run ASR,
  // text selected from a dropdown list, entered in a prompt, etc.
  string text = 2;
}

// Request to change the current story of a session.
message StoryRequest {
  // ID of the session that will have its story changed.
  string session_id = 1;

  // ID of the story to switch to. This ID is defined by the model
  // used to create the session.
  string story_id = 2;

  // Parameters to set in session memory before executing the specified
  // story. Some stories in the model may make assumptions about which
  // parameters have already been defined, so it is important to be
  // familiar with the model requirements for any given story.
  map<string, string> parameters = 3;

  // If true, the given story will not be executed until the session
  // completes the current stories and returns back to the main story.
  // If false, the current story in the session will be immediately
  // interrupted to execute the specified story.
  bool wait_for_start = 4;

  // If true, once the given story has finished, Diatheke will return
  // the session to the place in the model where it was when this request
  // was received. This is useful when the change in story represents a
  // temporary interruption. If false, Diatheke will simply continue
  // from the given story without trying to go back to its prior state,
  // which is useful to make a permanent state change.
  bool temporary = 5;
}

// Request for streaming ASR unrelated to a session.
message ASRRequest {
  oneof asr_data {
    // The Cubic model to use for ASR. This message should always be sent
    // before any audio data is sent.
    string model = 1;

    // Audio data to process. The encoding of the data should match what
    // was specified in the Diatheke server configuration.
    // NOTE: If the audio data is empty, the server may interpret it as
    //       the end of the stream and stop accepting further messages.
    bytes audio = 2;
  }
}

// ASRResponse contains speech recognition results.
message ASRResponse {
  // Text is the Cubic engine's formatted transcript of pushed audio.
  // This field will be the 1-best alternative.
  string text = 1;

  // The confidence score is a floating point number between 0.0 - 1.0. A
  // score of 1.0 indicates that the ASR engine is 100% confident in the
  // transcription.
  double confidence_score = 2;
}

// Request to synthesize speech unrelated to a session.
message TTSRequest {
  // The Luna model to use for TTS (defined in the server config file).
  string model = 1;

  // Text to synthesize
  string text = 2;
}

// Response for text-to-speech unrelated to a session.
message TTSResponse {
  // The synthesized audio data. The data encoding will match what was
  // specified in the server configuration.
  bytes data = 1;
}

message Empty {}
