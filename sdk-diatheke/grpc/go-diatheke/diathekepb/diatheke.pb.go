// Code generated by protoc-gen-go. DO NOT EDIT.
// source: diatheke.proto

package diathekepb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// CommandStatus are the resulting states of a command.
type CommandStatusUpdate_Data_CommandStatus int32

const (
	// SUCCESS indicates that the command was successfully completed, and the
	// dialog state may now move on to the next state.
	CommandStatusUpdate_Data_SUCCESS CommandStatusUpdate_Data_CommandStatus = 0
	// FAILURE indicates that the command was not successfully completed, and
	// the dialog state should be updated accordingly.
	CommandStatusUpdate_Data_FAILURE CommandStatusUpdate_Data_CommandStatus = 1
	// ALARM indicates (What? TODO)
	CommandStatusUpdate_Data_ALARM CommandStatusUpdate_Data_CommandStatus = 2
)

var CommandStatusUpdate_Data_CommandStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILURE",
	2: "ALARM",
}

var CommandStatusUpdate_Data_CommandStatus_value = map[string]int32{
	"SUCCESS": 0,
	"FAILURE": 1,
	"ALARM":   2,
}

func (x CommandStatusUpdate_Data_CommandStatus) String() string {
	return proto.EnumName(CommandStatusUpdate_Data_CommandStatus_name, int32(x))
}

func (CommandStatusUpdate_Data_CommandStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{9, 0, 0}
}

// The message sent by the server for the `Version` method.
type VersionResponse struct {
	// Server that manages all of the the other components.
	Server               string   `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionResponse) Reset()         { *m = VersionResponse{} }
func (m *VersionResponse) String() string { return proto.CompactTextString(m) }
func (*VersionResponse) ProtoMessage()    {}
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{0}
}

func (m *VersionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionResponse.Unmarshal(m, b)
}
func (m *VersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionResponse.Marshal(b, m, deterministic)
}
func (m *VersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionResponse.Merge(m, src)
}
func (m *VersionResponse) XXX_Size() int {
	return xxx_messageInfo_VersionResponse.Size(m)
}
func (m *VersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VersionResponse proto.InternalMessageInfo

func (m *VersionResponse) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

// The message sent by the server in response to a Models request.
// Returns an array of model names.
type ModelsResponse struct {
	// Array of models available for use.
	Models               []string `protobuf:"bytes,1,rep,name=models,proto3" json:"models,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModelsResponse) Reset()         { *m = ModelsResponse{} }
func (m *ModelsResponse) String() string { return proto.CompactTextString(m) }
func (*ModelsResponse) ProtoMessage()    {}
func (*ModelsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{1}
}

func (m *ModelsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModelsResponse.Unmarshal(m, b)
}
func (m *ModelsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModelsResponse.Marshal(b, m, deterministic)
}
func (m *ModelsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelsResponse.Merge(m, src)
}
func (m *ModelsResponse) XXX_Size() int {
	return xxx_messageInfo_ModelsResponse.Size(m)
}
func (m *ModelsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ModelsResponse proto.InternalMessageInfo

func (m *ModelsResponse) GetModels() []string {
	if m != nil {
		return m.Models
	}
	return nil
}

// Request for the NewSession call.
// TODO Concider combining the language and model into one string, such as
// `en_US_variant`.
type NewSessionRequest struct {
	// For applications that have more than one model to use for ASR/NLU.
	// ASR grammer can vary between models, as well as sets of commands.
	// Some applications will only have one model.
	Model                string   `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewSessionRequest) Reset()         { *m = NewSessionRequest{} }
func (m *NewSessionRequest) String() string { return proto.CompactTextString(m) }
func (*NewSessionRequest) ProtoMessage()    {}
func (*NewSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{2}
}

func (m *NewSessionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewSessionRequest.Unmarshal(m, b)
}
func (m *NewSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewSessionRequest.Marshal(b, m, deterministic)
}
func (m *NewSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewSessionRequest.Merge(m, src)
}
func (m *NewSessionRequest) XXX_Size() int {
	return xxx_messageInfo_NewSessionRequest.Size(m)
}
func (m *NewSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewSessionRequest proto.InternalMessageInfo

func (m *NewSessionRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

// Result of the NewSession call.
type NewSessionResponse struct {
	// Session ID that should be included with future calls.
	// Allows for reconnecting if the gRPC connection is dropped.
	// If an error occured, then this field will be an empty string ("").
	SessionId            string   `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewSessionResponse) Reset()         { *m = NewSessionResponse{} }
func (m *NewSessionResponse) String() string { return proto.CompactTextString(m) }
func (*NewSessionResponse) ProtoMessage()    {}
func (*NewSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{3}
}

func (m *NewSessionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewSessionResponse.Unmarshal(m, b)
}
func (m *NewSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewSessionResponse.Marshal(b, m, deterministic)
}
func (m *NewSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewSessionResponse.Merge(m, src)
}
func (m *NewSessionResponse) XXX_Size() int {
	return xxx_messageInfo_NewSessionResponse.Size(m)
}
func (m *NewSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NewSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NewSessionResponse proto.InternalMessageInfo

func (m *NewSessionResponse) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

// Request for the EndSession call.
type SessionEndRequest struct {
	// Session ID returned from the NewSession call.
	SessionId            string   `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionEndRequest) Reset()         { *m = SessionEndRequest{} }
func (m *SessionEndRequest) String() string { return proto.CompactTextString(m) }
func (*SessionEndRequest) ProtoMessage()    {}
func (*SessionEndRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{4}
}

func (m *SessionEndRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SessionEndRequest.Unmarshal(m, b)
}
func (m *SessionEndRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SessionEndRequest.Marshal(b, m, deterministic)
}
func (m *SessionEndRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionEndRequest.Merge(m, src)
}
func (m *SessionEndRequest) XXX_Size() int {
	return xxx_messageInfo_SessionEndRequest.Size(m)
}
func (m *SessionEndRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionEndRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionEndRequest proto.InternalMessageInfo

func (m *SessionEndRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

// To use ASR, audio is streamed to the server.  Multiple
// StreamingRecognizeRequest messages are sent. The first message must contain a
// session_id message only.  All subsequent messages must contain audio data
// only.  All AudioTranscriptionRequest messages must contain non-empty audio.
// If audio content is empty, the server may interpret it as end of stream and
// stop accepting any further messages.
type AudioTranscriptionRequest struct {
	// Types that are valid to be assigned to Request:
	//	*AudioTranscriptionRequest_SessionId
	//	*AudioTranscriptionRequest_Data
	Request              isAudioTranscriptionRequest_Request `protobuf_oneof:"request"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *AudioTranscriptionRequest) Reset()         { *m = AudioTranscriptionRequest{} }
func (m *AudioTranscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*AudioTranscriptionRequest) ProtoMessage()    {}
func (*AudioTranscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{5}
}

func (m *AudioTranscriptionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AudioTranscriptionRequest.Unmarshal(m, b)
}
func (m *AudioTranscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AudioTranscriptionRequest.Marshal(b, m, deterministic)
}
func (m *AudioTranscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioTranscriptionRequest.Merge(m, src)
}
func (m *AudioTranscriptionRequest) XXX_Size() int {
	return xxx_messageInfo_AudioTranscriptionRequest.Size(m)
}
func (m *AudioTranscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioTranscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AudioTranscriptionRequest proto.InternalMessageInfo

type isAudioTranscriptionRequest_Request interface {
	isAudioTranscriptionRequest_Request()
}

type AudioTranscriptionRequest_SessionId struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3,oneof"`
}

type AudioTranscriptionRequest_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*AudioTranscriptionRequest_SessionId) isAudioTranscriptionRequest_Request() {}

func (*AudioTranscriptionRequest_Data) isAudioTranscriptionRequest_Request() {}

func (m *AudioTranscriptionRequest) GetRequest() isAudioTranscriptionRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *AudioTranscriptionRequest) GetSessionId() string {
	if x, ok := m.GetRequest().(*AudioTranscriptionRequest_SessionId); ok {
		return x.SessionId
	}
	return ""
}

func (m *AudioTranscriptionRequest) GetData() []byte {
	if x, ok := m.GetRequest().(*AudioTranscriptionRequest_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AudioTranscriptionRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AudioTranscriptionRequest_SessionId)(nil),
		(*AudioTranscriptionRequest_Data)(nil),
	}
}

// TranscriptionResult will either be the transcribed text, or an error message.
// TranscriptionResult is sent whenenver the Cubic engine endpoints an audio
// segment.
type TranscriptionResult struct {
	// Session ID returned from the NewSession call.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Text is the Cubic engine's formatted transcript of pushed audio.
	// Transcribed text, with formatting applied.
	// This field will be the 1-best alternative.
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	// The confidence score is a floating point number 0.0-1.0, on how confident the
	// ASR engine is in that transcription.
	ConfidenceScore      float64  `protobuf:"fixed64,3,opt,name=confidence_score,json=confidenceScore,proto3" json:"confidence_score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TranscriptionResult) Reset()         { *m = TranscriptionResult{} }
func (m *TranscriptionResult) String() string { return proto.CompactTextString(m) }
func (*TranscriptionResult) ProtoMessage()    {}
func (*TranscriptionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{6}
}

func (m *TranscriptionResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranscriptionResult.Unmarshal(m, b)
}
func (m *TranscriptionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranscriptionResult.Marshal(b, m, deterministic)
}
func (m *TranscriptionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranscriptionResult.Merge(m, src)
}
func (m *TranscriptionResult) XXX_Size() int {
	return xxx_messageInfo_TranscriptionResult.Size(m)
}
func (m *TranscriptionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TranscriptionResult.DiscardUnknown(m)
}

var xxx_messageInfo_TranscriptionResult proto.InternalMessageInfo

func (m *TranscriptionResult) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *TranscriptionResult) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *TranscriptionResult) GetConfidenceScore() float64 {
	if m != nil {
		return m.ConfidenceScore
	}
	return 0
}

// Request for adding User Input directly from text.
type PushTextRequest struct {
	// Session ID returned from the NewSession call.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// User input, like a transcription from ASR.
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PushTextRequest) Reset()         { *m = PushTextRequest{} }
func (m *PushTextRequest) String() string { return proto.CompactTextString(m) }
func (*PushTextRequest) ProtoMessage()    {}
func (*PushTextRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{7}
}

func (m *PushTextRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PushTextRequest.Unmarshal(m, b)
}
func (m *PushTextRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PushTextRequest.Marshal(b, m, deterministic)
}
func (m *PushTextRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushTextRequest.Merge(m, src)
}
func (m *PushTextRequest) XXX_Size() int {
	return xxx_messageInfo_PushTextRequest.Size(m)
}
func (m *PushTextRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushTextRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushTextRequest proto.InternalMessageInfo

func (m *PushTextRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *PushTextRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// CommandToExecute indicates Diatheke found an actionable state in the dialog,
// and requests the application manager to perform the command.
type CommandToExecute struct {
	// session_id should be the same as the status id returned from
	// NewSessionResponse.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// ID of the command that should be run.  i.e. "COM01" for Command #01.
	CommandId string `protobuf:"bytes,2,opt,name=command_id,json=commandId,proto3" json:"command_id,omitempty"`
	// parameters is a generic map of parameter name to parameter value.  These
	// parameters are defined in the Diatheke Models.
	Parameters map[string]string `protobuf:"bytes,3,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The state_data field contains information about the state in which this
	// notification should be handled.
	// Since there can be multiple states being tracked in a single session,
	// this value must be sent with the CommandStatusUpdate that follow from
	// the commands execution.
	StateData            string   `protobuf:"bytes,4,opt,name=state_data,json=stateData,proto3" json:"state_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandToExecute) Reset()         { *m = CommandToExecute{} }
func (m *CommandToExecute) String() string { return proto.CompactTextString(m) }
func (*CommandToExecute) ProtoMessage()    {}
func (*CommandToExecute) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{8}
}

func (m *CommandToExecute) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandToExecute.Unmarshal(m, b)
}
func (m *CommandToExecute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandToExecute.Marshal(b, m, deterministic)
}
func (m *CommandToExecute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandToExecute.Merge(m, src)
}
func (m *CommandToExecute) XXX_Size() int {
	return xxx_messageInfo_CommandToExecute.Size(m)
}
func (m *CommandToExecute) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandToExecute.DiscardUnknown(m)
}

var xxx_messageInfo_CommandToExecute proto.InternalMessageInfo

func (m *CommandToExecute) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *CommandToExecute) GetCommandId() string {
	if m != nil {
		return m.CommandId
	}
	return ""
}

func (m *CommandToExecute) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *CommandToExecute) GetStateData() string {
	if m != nil {
		return m.StateData
	}
	return ""
}

type CommandStatusUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*CommandStatusUpdate_SessionId
	//	*CommandStatusUpdate_Data_
	Update               isCommandStatusUpdate_Update `protobuf_oneof:"update"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *CommandStatusUpdate) Reset()         { *m = CommandStatusUpdate{} }
func (m *CommandStatusUpdate) String() string { return proto.CompactTextString(m) }
func (*CommandStatusUpdate) ProtoMessage()    {}
func (*CommandStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{9}
}

func (m *CommandStatusUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandStatusUpdate.Unmarshal(m, b)
}
func (m *CommandStatusUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandStatusUpdate.Marshal(b, m, deterministic)
}
func (m *CommandStatusUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStatusUpdate.Merge(m, src)
}
func (m *CommandStatusUpdate) XXX_Size() int {
	return xxx_messageInfo_CommandStatusUpdate.Size(m)
}
func (m *CommandStatusUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStatusUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStatusUpdate proto.InternalMessageInfo

type isCommandStatusUpdate_Update interface {
	isCommandStatusUpdate_Update()
}

type CommandStatusUpdate_SessionId struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3,oneof"`
}

type CommandStatusUpdate_Data_ struct {
	Data *CommandStatusUpdate_Data `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*CommandStatusUpdate_SessionId) isCommandStatusUpdate_Update() {}

func (*CommandStatusUpdate_Data_) isCommandStatusUpdate_Update() {}

func (m *CommandStatusUpdate) GetUpdate() isCommandStatusUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *CommandStatusUpdate) GetSessionId() string {
	if x, ok := m.GetUpdate().(*CommandStatusUpdate_SessionId); ok {
		return x.SessionId
	}
	return ""
}

func (m *CommandStatusUpdate) GetData() *CommandStatusUpdate_Data {
	if x, ok := m.GetUpdate().(*CommandStatusUpdate_Data_); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CommandStatusUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CommandStatusUpdate_SessionId)(nil),
		(*CommandStatusUpdate_Data_)(nil),
	}
}

type CommandStatusUpdate_Data struct {
	// ID of the command that should be run.  i.e. "COM01" for Command #01.
	CommandId     string                                 `protobuf:"bytes,1,opt,name=command_id,json=commandId,proto3" json:"command_id,omitempty"`
	CommandStatus CommandStatusUpdate_Data_CommandStatus `protobuf:"varint,2,opt,name=command_status,json=commandStatus,proto3,enum=cobaltspeech.diatheke.CommandStatusUpdate_Data_CommandStatus" json:"command_status,omitempty"`
	// The state_data field contains information about the state in which this
	// notification should be handled.
	// TODO: Why do we have this in the HTTP interface?  Can we hide it in the
	// gRPC interface?
	StateData string `protobuf:"bytes,3,opt,name=state_data,json=stateData,proto3" json:"state_data,omitempty"`
	// parameters is a generic map of parameter name to parameter value.  These
	// parameters are defined in the Diatheke Models.  An example could be the
	// "TV Channel" is "Channel 2".
	Parameters map[string]string `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// error_message_text will be populated when there is a error occures while
	// executing a command.  This string will be sent through TTS and posted to
	// the SayCallback as an audio file.
	ErrorMessageText     string   `protobuf:"bytes,5,opt,name=error_message_text,json=errorMessageText,proto3" json:"error_message_text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandStatusUpdate_Data) Reset()         { *m = CommandStatusUpdate_Data{} }
func (m *CommandStatusUpdate_Data) String() string { return proto.CompactTextString(m) }
func (*CommandStatusUpdate_Data) ProtoMessage()    {}
func (*CommandStatusUpdate_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{9, 0}
}

func (m *CommandStatusUpdate_Data) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandStatusUpdate_Data.Unmarshal(m, b)
}
func (m *CommandStatusUpdate_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandStatusUpdate_Data.Marshal(b, m, deterministic)
}
func (m *CommandStatusUpdate_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStatusUpdate_Data.Merge(m, src)
}
func (m *CommandStatusUpdate_Data) XXX_Size() int {
	return xxx_messageInfo_CommandStatusUpdate_Data.Size(m)
}
func (m *CommandStatusUpdate_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStatusUpdate_Data.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStatusUpdate_Data proto.InternalMessageInfo

func (m *CommandStatusUpdate_Data) GetCommandId() string {
	if m != nil {
		return m.CommandId
	}
	return ""
}

func (m *CommandStatusUpdate_Data) GetCommandStatus() CommandStatusUpdate_Data_CommandStatus {
	if m != nil {
		return m.CommandStatus
	}
	return CommandStatusUpdate_Data_SUCCESS
}

func (m *CommandStatusUpdate_Data) GetStateData() string {
	if m != nil {
		return m.StateData
	}
	return ""
}

func (m *CommandStatusUpdate_Data) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *CommandStatusUpdate_Data) GetErrorMessageText() string {
	if m != nil {
		return m.ErrorMessageText
	}
	return ""
}

// TTSResponse contains the sythesised audio waveform for a TTS request.
type TTSResponse struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Text to synthesize.
	// When responding to a Say(TTSRequest) call, it is the same string that was
	// in TTSRequest.text. When it comes from a Notify(CommandStatusUpdate) call,
	// it is the same string that was in the
	// CommandStatusUpdate.error_message_text.
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	// data contains the audio waveform as an array of bytes.
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TTSResponse) Reset()         { *m = TTSResponse{} }
func (m *TTSResponse) String() string { return proto.CompactTextString(m) }
func (*TTSResponse) ProtoMessage()    {}
func (*TTSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{10}
}

func (m *TTSResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TTSResponse.Unmarshal(m, b)
}
func (m *TTSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TTSResponse.Marshal(b, m, deterministic)
}
func (m *TTSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TTSResponse.Merge(m, src)
}
func (m *TTSResponse) XXX_Size() int {
	return xxx_messageInfo_TTSResponse.Size(m)
}
func (m *TTSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TTSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TTSResponse proto.InternalMessageInfo

func (m *TTSResponse) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *TTSResponse) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *TTSResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Request to stynthesize audio for a given string.
type TTSRequest struct {
	// Session ID returned from the NewSession call.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Text to synthesize.
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TTSRequest) Reset()         { *m = TTSRequest{} }
func (m *TTSRequest) String() string { return proto.CompactTextString(m) }
func (*TTSRequest) ProtoMessage()    {}
func (*TTSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{11}
}

func (m *TTSRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TTSRequest.Unmarshal(m, b)
}
func (m *TTSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TTSRequest.Marshal(b, m, deterministic)
}
func (m *TTSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TTSRequest.Merge(m, src)
}
func (m *TTSRequest) XXX_Size() int {
	return xxx_messageInfo_TTSRequest.Size(m)
}
func (m *TTSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TTSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TTSRequest proto.InternalMessageInfo

func (m *TTSRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *TTSRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type SayCallbackRequest struct {
	// Session ID returned from the NewSession call.
	SessionId            string   `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SayCallbackRequest) Reset()         { *m = SayCallbackRequest{} }
func (m *SayCallbackRequest) String() string { return proto.CompactTextString(m) }
func (*SayCallbackRequest) ProtoMessage()    {}
func (*SayCallbackRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{12}
}

func (m *SayCallbackRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SayCallbackRequest.Unmarshal(m, b)
}
func (m *SayCallbackRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SayCallbackRequest.Marshal(b, m, deterministic)
}
func (m *SayCallbackRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SayCallbackRequest.Merge(m, src)
}
func (m *SayCallbackRequest) XXX_Size() int {
	return xxx_messageInfo_SayCallbackRequest.Size(m)
}
func (m *SayCallbackRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SayCallbackRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SayCallbackRequest proto.InternalMessageInfo

func (m *SayCallbackRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d1ed59c94a181ed, []int{13}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cobaltspeech.diatheke.CommandStatusUpdate_Data_CommandStatus", CommandStatusUpdate_Data_CommandStatus_name, CommandStatusUpdate_Data_CommandStatus_value)
	proto.RegisterType((*VersionResponse)(nil), "cobaltspeech.diatheke.VersionResponse")
	proto.RegisterType((*ModelsResponse)(nil), "cobaltspeech.diatheke.ModelsResponse")
	proto.RegisterType((*NewSessionRequest)(nil), "cobaltspeech.diatheke.NewSessionRequest")
	proto.RegisterType((*NewSessionResponse)(nil), "cobaltspeech.diatheke.NewSessionResponse")
	proto.RegisterType((*SessionEndRequest)(nil), "cobaltspeech.diatheke.SessionEndRequest")
	proto.RegisterType((*AudioTranscriptionRequest)(nil), "cobaltspeech.diatheke.AudioTranscriptionRequest")
	proto.RegisterType((*TranscriptionResult)(nil), "cobaltspeech.diatheke.TranscriptionResult")
	proto.RegisterType((*PushTextRequest)(nil), "cobaltspeech.diatheke.PushTextRequest")
	proto.RegisterType((*CommandToExecute)(nil), "cobaltspeech.diatheke.CommandToExecute")
	proto.RegisterMapType((map[string]string)(nil), "cobaltspeech.diatheke.CommandToExecute.ParametersEntry")
	proto.RegisterType((*CommandStatusUpdate)(nil), "cobaltspeech.diatheke.CommandStatusUpdate")
	proto.RegisterType((*CommandStatusUpdate_Data)(nil), "cobaltspeech.diatheke.CommandStatusUpdate.Data")
	proto.RegisterMapType((map[string]string)(nil), "cobaltspeech.diatheke.CommandStatusUpdate.Data.ParametersEntry")
	proto.RegisterType((*TTSResponse)(nil), "cobaltspeech.diatheke.TTSResponse")
	proto.RegisterType((*TTSRequest)(nil), "cobaltspeech.diatheke.TTSRequest")
	proto.RegisterType((*SayCallbackRequest)(nil), "cobaltspeech.diatheke.SayCallbackRequest")
	proto.RegisterType((*Empty)(nil), "cobaltspeech.diatheke.Empty")
}

func init() { proto.RegisterFile("diatheke.proto", fileDescriptor_6d1ed59c94a181ed) }

var fileDescriptor_6d1ed59c94a181ed = []byte{
	// 805 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xef, 0x6e, 0xe2, 0x46,
	0x10, 0xc7, 0x98, 0x3f, 0x61, 0x48, 0x80, 0x6c, 0xd2, 0x8a, 0x5a, 0xad, 0x4a, 0x57, 0x6a, 0x0b,
	0x51, 0x45, 0x23, 0x52, 0xa9, 0x55, 0xa5, 0x28, 0x22, 0xc4, 0x55, 0x22, 0x25, 0x69, 0x6a, 0x93,
	0x54, 0xaa, 0x54, 0xd1, 0xc5, 0xde, 0x34, 0x28, 0x60, 0xbb, 0xde, 0x75, 0x1a, 0x9e, 0xe0, 0xde,
	0xe6, 0x3e, 0xdf, 0x3b, 0xdc, 0x4b, 0x9d, 0xbc, 0x36, 0xc4, 0x18, 0x8c, 0xc9, 0xdd, 0x37, 0xcf,
	0xcc, 0xce, 0x6f, 0xfe, 0xee, 0xfe, 0x0c, 0x15, 0x73, 0x44, 0xf8, 0x03, 0x7d, 0xa4, 0x6d, 0xc7,
	0xb5, 0xb9, 0x8d, 0x3e, 0x33, 0xec, 0x21, 0x19, 0x73, 0xe6, 0x50, 0x6a, 0x3c, 0xb4, 0x67, 0x46,
	0xdc, 0x82, 0xea, 0x1d, 0x75, 0xd9, 0xc8, 0xb6, 0x34, 0xca, 0x1c, 0xdb, 0x62, 0x14, 0x7d, 0x0e,
	0x05, 0x46, 0xdd, 0x27, 0xea, 0xd6, 0xa5, 0x86, 0xd4, 0x2c, 0x69, 0xa1, 0x84, 0x9b, 0x50, 0xb9,
	0xb2, 0x4d, 0x3a, 0x66, 0xd1, 0x93, 0x13, 0xa1, 0xa9, 0x4b, 0x0d, 0xd9, 0x3f, 0x19, 0x48, 0xb8,
	0x05, 0xbb, 0xd7, 0xf4, 0x7f, 0x9d, 0xb2, 0x00, 0xf7, 0x3f, 0x8f, 0x32, 0x8e, 0xf6, 0x21, 0x2f,
	0xcc, 0x21, 0x6a, 0x20, 0xe0, 0x23, 0x40, 0xd1, 0xa3, 0x21, 0xf0, 0x57, 0x00, 0x2c, 0x50, 0x0d,
	0x46, 0x66, 0xe8, 0x50, 0x0a, 0x35, 0x17, 0x26, 0xee, 0xc0, 0x6e, 0xe8, 0xa1, 0x5a, 0xe6, 0x0c,
	0x3f, 0xc5, 0xe7, 0x6f, 0xf8, 0xa2, 0xeb, 0x99, 0x23, 0xbb, 0xef, 0x12, 0x8b, 0x19, 0xee, 0xc8,
	0xe1, 0x91, 0xdc, 0xbe, 0x5e, 0xf6, 0x3d, 0xcf, 0x44, 0xbc, 0xd1, 0x3e, 0xe4, 0x4c, 0xc2, 0x49,
	0x3d, 0xdb, 0x90, 0x9a, 0xdb, 0xe7, 0x19, 0x4d, 0x48, 0xa7, 0x25, 0x28, 0xba, 0x01, 0x02, 0x66,
	0xb0, 0x17, 0x43, 0x66, 0xde, 0x38, 0x2d, 0x29, 0x84, 0x20, 0xc7, 0xe9, 0x33, 0x17, 0xb0, 0x25,
	0x4d, 0x7c, 0xa3, 0x16, 0xd4, 0x0c, 0xdb, 0xba, 0x1f, 0x99, 0xd4, 0x32, 0xe8, 0x80, 0x19, 0xb6,
	0x4b, 0xeb, 0x72, 0x43, 0x6a, 0x4a, 0x5a, 0xf5, 0x45, 0xaf, 0xfb, 0x6a, 0x7c, 0x06, 0xd5, 0x1b,
	0x8f, 0x3d, 0xf4, 0xe9, 0x33, 0xdf, 0xac, 0x0b, 0xab, 0x02, 0xe2, 0x37, 0x59, 0xa8, 0xf5, 0xec,
	0xc9, 0x84, 0x58, 0x66, 0xdf, 0x56, 0x9f, 0xa9, 0xe1, 0xf1, 0xb4, 0x09, 0xf8, 0x66, 0x23, 0x70,
	0xf1, 0xcd, 0x01, 0x5a, 0x29, 0xd4, 0x5c, 0x98, 0xe8, 0x4f, 0x00, 0x87, 0xb8, 0x64, 0x42, 0x39,
	0x75, 0x59, 0x5d, 0x6e, 0xc8, 0xcd, 0x72, 0xe7, 0xe7, 0xf6, 0xca, 0x0d, 0x6c, 0xc7, 0x43, 0xb7,
	0x6f, 0xe6, 0x9e, 0xaa, 0xc5, 0xdd, 0xa9, 0x16, 0x81, 0x12, 0x69, 0x71, 0xc2, 0xe9, 0x40, 0x4c,
	0x23, 0x17, 0xa6, 0xe5, 0x6b, 0xce, 0x08, 0x27, 0xca, 0x31, 0x54, 0x63, 0xde, 0xa8, 0x06, 0xf2,
	0x23, 0x9d, 0x86, 0x15, 0xf8, 0x9f, 0xfe, 0x22, 0x3e, 0x91, 0xb1, 0x47, 0xc3, 0xb4, 0x03, 0xe1,
	0xd7, 0xec, 0x2f, 0x12, 0x7e, 0x97, 0x83, 0xbd, 0x30, 0x1d, 0x9d, 0x13, 0xee, 0xb1, 0x5b, 0xc7,
	0x24, 0x9c, 0xa6, 0xaf, 0x87, 0x1a, 0x59, 0x8f, 0x72, 0xe7, 0xc7, 0xf5, 0x95, 0x46, 0xa1, 0xdb,
	0x7e, 0xda, 0xb3, 0x7d, 0x52, 0xde, 0xca, 0x90, 0xf3, 0x15, 0xb1, 0xf6, 0x4a, 0xf1, 0xf6, 0x9a,
	0x50, 0x99, 0x99, 0x99, 0x00, 0x13, 0x81, 0x2b, 0x9d, 0xe3, 0x57, 0x06, 0x5e, 0x34, 0x68, 0x3b,
	0x46, 0x54, 0x8c, 0xf5, 0x5a, 0x8e, 0xf5, 0x1a, 0x0d, 0x16, 0x66, 0x9c, 0x13, 0x33, 0x3e, 0x79,
	0x6d, 0x02, 0xeb, 0x66, 0xfd, 0x03, 0x20, 0xea, 0xba, 0xb6, 0x3b, 0x98, 0x50, 0xc6, 0xc8, 0xbf,
	0x74, 0x20, 0x36, 0x37, 0x2f, 0xf2, 0xa8, 0x09, 0xcb, 0x55, 0x60, 0xf0, 0xf7, 0xff, 0x53, 0x47,
	0xff, 0x13, 0xec, 0x2c, 0x24, 0x89, 0xca, 0x50, 0xd4, 0x6f, 0x7b, 0x3d, 0x55, 0xd7, 0x6b, 0x19,
	0x5f, 0xf8, 0xad, 0x7b, 0x71, 0x79, 0xab, 0xa9, 0x35, 0x09, 0x95, 0x20, 0xdf, 0xbd, 0xec, 0x6a,
	0x57, 0xb5, 0xec, 0xe9, 0x16, 0x14, 0x3c, 0x51, 0x0d, 0xee, 0x43, 0xb9, 0xdf, 0xd7, 0x37, 0x7c,
	0xc0, 0x56, 0xde, 0x7b, 0x14, 0xee, 0x90, 0xdf, 0xe8, 0xed, 0x60, 0x21, 0xf0, 0x09, 0x80, 0x40,
	0xfd, 0xe8, 0xbb, 0x7d, 0x04, 0x48, 0x27, 0xd3, 0x1e, 0x19, 0x8f, 0x87, 0xc4, 0x78, 0xdc, 0xf0,
	0xa9, 0x2c, 0x42, 0x5e, 0x9d, 0x38, 0x7c, 0xda, 0x79, 0x5f, 0x80, 0xad, 0xb3, 0x70, 0x86, 0xe8,
	0x0f, 0x28, 0x86, 0x4c, 0x81, 0xbe, 0x4c, 0x18, 0xb3, 0xf0, 0x52, 0xbe, 0x4b, 0xb0, 0xc6, 0x78,
	0x06, 0x67, 0xd0, 0xef, 0x50, 0x08, 0x18, 0x25, 0x05, 0xf1, 0xdb, 0x04, 0xeb, 0x22, 0x1d, 0xe1,
	0x0c, 0x32, 0x00, 0x5e, 0xd8, 0x04, 0x35, 0x13, 0xdc, 0x96, 0xb8, 0x49, 0x69, 0x6d, 0x70, 0x72,
	0x1e, 0xe4, 0x0e, 0x40, 0xb5, 0xcc, 0xb4, 0x20, 0x4b, 0x04, 0xa5, 0xac, 0xad, 0x11, 0x67, 0x90,
	0x0d, 0x25, 0xff, 0x35, 0x17, 0x2c, 0x85, 0x0e, 0x13, 0x0e, 0x27, 0x72, 0x98, 0x72, 0x90, 0xe0,
	0xb1, 0x82, 0x96, 0x70, 0xa6, 0x29, 0x1d, 0x4a, 0x48, 0x83, 0xad, 0x19, 0x7d, 0xa0, 0xa4, 0xa1,
	0xc5, 0xf8, 0x25, 0xb5, 0x88, 0xc9, 0x9c, 0x4b, 0xba, 0x96, 0x79, 0x6d, 0xf3, 0xd1, 0xfd, 0x14,
	0x1d, 0x6c, 0xfe, 0x2a, 0x28, 0xdf, 0x6f, 0xc8, 0x12, 0x61, 0x09, 0xe7, 0x20, 0xeb, 0x64, 0x8a,
	0xbe, 0x49, 0xaa, 0x7d, 0x7e, 0x79, 0x52, 0x13, 0xff, 0x07, 0xca, 0x91, 0x9b, 0x82, 0x92, 0x36,
	0x62, 0xf9, 0x36, 0x29, 0x78, 0x5d, 0xf0, 0xd9, 0xd6, 0x1c, 0x4a, 0xa7, 0xdb, 0x7f, 0xc1, 0xcc,
	0xe6, 0x0c, 0x87, 0x05, 0xf1, 0x5b, 0x76, 0xf4, 0x21, 0x00, 0x00, 0xff, 0xff, 0xa1, 0xcc, 0xbf,
	0xa4, 0xa8, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DiathekeClient is the client API for Diatheke service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DiathekeClient interface {
	// Queries the Version of the Server.
	Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	// Models will return a list of available versions.  This value should be used
	// to the NewSession calls.
	Models(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ModelsResponse, error)
	// Requests a new session with the given config, returns a new ID.
	// This new ID should be used with all future calls.
	NewSession(ctx context.Context, in *NewSessionRequest, opts ...grpc.CallOption) (*NewSessionResponse, error)
	// Terminates an existing session.
	// It is an error if the SessionEndRequest has an invalid SessionID.
	EndSession(ctx context.Context, in *SessionEndRequest, opts ...grpc.CallOption) (*Empty, error)
	// Performs bidirectional streaming speech recognition.  As transcripts are
	// generated, the result is both sent to the caller and passed on to the
	// dialog management system. The dialog management path happens asyncronously,
	// and will update the application manager through the CommandCallback and
	// SayCallback calls.
	//
	// TODO, since this is a streaming api, and we endpoint once it closes, it is
	// hard to support an HTTP interface.  The sim server would need to keep this
	// call alive between calls to their PushAudio API, and maybe have their own
	// EndPoint API that is responsible for shutting down the old one. Also, they
	// would need to keep a call for each session.
	//   Would it make sense to have a streaming call remain open, one for each
	// session in a map.  If there is an existing connection, then push the next
	// audio clip on the existing one.  If there is not an exist connection, then
	// we create a new connection which we then store and use.  When their users
	// call the EndpointAudio API, they can close the existing connection, and
	// remove it from the map.
	//   Is that better or worse than adding an EndpointAudio gRPC call?
	//   Since it seems doable without the EndpointAudio gRPC call, I think the
	// last question to ask is how do we handle responses.  Returning a stream of
	// TranscriptionResults means they have to start/stop the callback listener,
	// but that doesn't seem to be a problem.  The storage on their side is the
	// same either way.
	//   Jacobs thoughts:  I think it should be ok to exclude the EndpointAudio
	// gRPC, endpoint when the PushAudio
	//
	// TODO, can a single session have mroe than one audio stream?  While it seems
	// like it could be valid, I think it's fine to lock it down to one stream per
	// session.
	PushAudio(ctx context.Context, opts ...grpc.CallOption) (Diatheke_PushAudioClient, error)
	// PushText will sidestep the ASR portion and simply push a "Transcript"
	// directly to the dialog management.  The dialog management path will happen
	// asyncronously via the CommandCallback and  SayCallback calls, same
	// as with PushAudio.
	//
	// For frontends that display a transcript of the conversation, transcribed
	// text will be streamed back from the PushAudio call. Text sent via the
	// PushText will not be returned, so you may add it to the history right away.
	PushText(ctx context.Context, in *PushTextRequest, opts ...grpc.CallOption) (*Empty, error)
	// CommandAndNotify is a bi-directional stream that handles the interactions
	// of commands and notifications between the client and server.  By using the
	// bi-directional streaming, either side can initiate a new chain of
	// interactions.
	//
	// Commands:
	// When the dialog management finds enough context to indicate a command
	// should be executed, it sends a Command object back to the application
	// manager to execute.
	//
	// Please note: When a new command that is accompanied by a TTS step is
	// triggered, that TTS will be sent on the SayCallback rpc.
	//
	// Notificiations:
	// Notifications are sent by the application manager to update the dialog
	// state. Depending on the application, there can be some delay between the
	// initation of a command execution and the completion of that step.  Some
	// other applications may have multiple updates for the same command.  Both of
	// these benefit from making this an asynchronous pattern.
	CommandAndNotify(ctx context.Context, opts ...grpc.CallOption) (Diatheke_CommandAndNotifyClient, error)
	// Say may be used to request TTS synthesis on given text, independent of any
	// dialog state changes.
	// Results will come back via the SayCallback stream.
	Say(ctx context.Context, in *TTSRequest, opts ...grpc.CallOption) (*Empty, error)
	// SayCallback is triggered whenever there is a new TTS audio clip that should
	// be played for the user.  This can come from the dialog management pushing a
	// Say action.
	// TTSResponses from the client making a Say(TTSRequest) call  will be
	// returned from that call, not through this callback.
	//
	// Please note:  When a new TTS that is accompanied by a Command is triggered,
	// that Command will be sent on the CommandCallback rpc.
	SayCallback(ctx context.Context, in *SayCallbackRequest, opts ...grpc.CallOption) (Diatheke_SayCallbackClient, error)
}

type diathekeClient struct {
	cc *grpc.ClientConn
}

func NewDiathekeClient(cc *grpc.ClientConn) DiathekeClient {
	return &diathekeClient{cc}
}

func (c *diathekeClient) Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) Models(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ModelsResponse, error) {
	out := new(ModelsResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/Models", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) NewSession(ctx context.Context, in *NewSessionRequest, opts ...grpc.CallOption) (*NewSessionResponse, error) {
	out := new(NewSessionResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/NewSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) EndSession(ctx context.Context, in *SessionEndRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/EndSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) PushAudio(ctx context.Context, opts ...grpc.CallOption) (Diatheke_PushAudioClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[0], "/cobaltspeech.diatheke.Diatheke/PushAudio", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekePushAudioClient{stream}
	return x, nil
}

type Diatheke_PushAudioClient interface {
	Send(*AudioTranscriptionRequest) error
	Recv() (*TranscriptionResult, error)
	grpc.ClientStream
}

type diathekePushAudioClient struct {
	grpc.ClientStream
}

func (x *diathekePushAudioClient) Send(m *AudioTranscriptionRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *diathekePushAudioClient) Recv() (*TranscriptionResult, error) {
	m := new(TranscriptionResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diathekeClient) PushText(ctx context.Context, in *PushTextRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/PushText", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) CommandAndNotify(ctx context.Context, opts ...grpc.CallOption) (Diatheke_CommandAndNotifyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[1], "/cobaltspeech.diatheke.Diatheke/CommandAndNotify", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeCommandAndNotifyClient{stream}
	return x, nil
}

type Diatheke_CommandAndNotifyClient interface {
	Send(*CommandStatusUpdate) error
	Recv() (*CommandToExecute, error)
	grpc.ClientStream
}

type diathekeCommandAndNotifyClient struct {
	grpc.ClientStream
}

func (x *diathekeCommandAndNotifyClient) Send(m *CommandStatusUpdate) error {
	return x.ClientStream.SendMsg(m)
}

func (x *diathekeCommandAndNotifyClient) Recv() (*CommandToExecute, error) {
	m := new(CommandToExecute)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diathekeClient) Say(ctx context.Context, in *TTSRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/cobaltspeech.diatheke.Diatheke/Say", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diathekeClient) SayCallback(ctx context.Context, in *SayCallbackRequest, opts ...grpc.CallOption) (Diatheke_SayCallbackClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Diatheke_serviceDesc.Streams[2], "/cobaltspeech.diatheke.Diatheke/SayCallback", opts...)
	if err != nil {
		return nil, err
	}
	x := &diathekeSayCallbackClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Diatheke_SayCallbackClient interface {
	Recv() (*TTSResponse, error)
	grpc.ClientStream
}

type diathekeSayCallbackClient struct {
	grpc.ClientStream
}

func (x *diathekeSayCallbackClient) Recv() (*TTSResponse, error) {
	m := new(TTSResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DiathekeServer is the server API for Diatheke service.
type DiathekeServer interface {
	// Queries the Version of the Server.
	Version(context.Context, *Empty) (*VersionResponse, error)
	// Models will return a list of available versions.  This value should be used
	// to the NewSession calls.
	Models(context.Context, *Empty) (*ModelsResponse, error)
	// Requests a new session with the given config, returns a new ID.
	// This new ID should be used with all future calls.
	NewSession(context.Context, *NewSessionRequest) (*NewSessionResponse, error)
	// Terminates an existing session.
	// It is an error if the SessionEndRequest has an invalid SessionID.
	EndSession(context.Context, *SessionEndRequest) (*Empty, error)
	// Performs bidirectional streaming speech recognition.  As transcripts are
	// generated, the result is both sent to the caller and passed on to the
	// dialog management system. The dialog management path happens asyncronously,
	// and will update the application manager through the CommandCallback and
	// SayCallback calls.
	//
	// TODO, since this is a streaming api, and we endpoint once it closes, it is
	// hard to support an HTTP interface.  The sim server would need to keep this
	// call alive between calls to their PushAudio API, and maybe have their own
	// EndPoint API that is responsible for shutting down the old one. Also, they
	// would need to keep a call for each session.
	//   Would it make sense to have a streaming call remain open, one for each
	// session in a map.  If there is an existing connection, then push the next
	// audio clip on the existing one.  If there is not an exist connection, then
	// we create a new connection which we then store and use.  When their users
	// call the EndpointAudio API, they can close the existing connection, and
	// remove it from the map.
	//   Is that better or worse than adding an EndpointAudio gRPC call?
	//   Since it seems doable without the EndpointAudio gRPC call, I think the
	// last question to ask is how do we handle responses.  Returning a stream of
	// TranscriptionResults means they have to start/stop the callback listener,
	// but that doesn't seem to be a problem.  The storage on their side is the
	// same either way.
	//   Jacobs thoughts:  I think it should be ok to exclude the EndpointAudio
	// gRPC, endpoint when the PushAudio
	//
	// TODO, can a single session have mroe than one audio stream?  While it seems
	// like it could be valid, I think it's fine to lock it down to one stream per
	// session.
	PushAudio(Diatheke_PushAudioServer) error
	// PushText will sidestep the ASR portion and simply push a "Transcript"
	// directly to the dialog management.  The dialog management path will happen
	// asyncronously via the CommandCallback and  SayCallback calls, same
	// as with PushAudio.
	//
	// For frontends that display a transcript of the conversation, transcribed
	// text will be streamed back from the PushAudio call. Text sent via the
	// PushText will not be returned, so you may add it to the history right away.
	PushText(context.Context, *PushTextRequest) (*Empty, error)
	// CommandAndNotify is a bi-directional stream that handles the interactions
	// of commands and notifications between the client and server.  By using the
	// bi-directional streaming, either side can initiate a new chain of
	// interactions.
	//
	// Commands:
	// When the dialog management finds enough context to indicate a command
	// should be executed, it sends a Command object back to the application
	// manager to execute.
	//
	// Please note: When a new command that is accompanied by a TTS step is
	// triggered, that TTS will be sent on the SayCallback rpc.
	//
	// Notificiations:
	// Notifications are sent by the application manager to update the dialog
	// state. Depending on the application, there can be some delay between the
	// initation of a command execution and the completion of that step.  Some
	// other applications may have multiple updates for the same command.  Both of
	// these benefit from making this an asynchronous pattern.
	CommandAndNotify(Diatheke_CommandAndNotifyServer) error
	// Say may be used to request TTS synthesis on given text, independent of any
	// dialog state changes.
	// Results will come back via the SayCallback stream.
	Say(context.Context, *TTSRequest) (*Empty, error)
	// SayCallback is triggered whenever there is a new TTS audio clip that should
	// be played for the user.  This can come from the dialog management pushing a
	// Say action.
	// TTSResponses from the client making a Say(TTSRequest) call  will be
	// returned from that call, not through this callback.
	//
	// Please note:  When a new TTS that is accompanied by a Command is triggered,
	// that Command will be sent on the CommandCallback rpc.
	SayCallback(*SayCallbackRequest, Diatheke_SayCallbackServer) error
}

func RegisterDiathekeServer(s *grpc.Server, srv DiathekeServer) {
	s.RegisterService(&_Diatheke_serviceDesc, srv)
}

func _Diatheke_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).Version(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_Models_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).Models(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/Models",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).Models(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_NewSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).NewSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/NewSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).NewSession(ctx, req.(*NewSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/EndSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).EndSession(ctx, req.(*SessionEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_PushAudio_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DiathekeServer).PushAudio(&diathekePushAudioServer{stream})
}

type Diatheke_PushAudioServer interface {
	Send(*TranscriptionResult) error
	Recv() (*AudioTranscriptionRequest, error)
	grpc.ServerStream
}

type diathekePushAudioServer struct {
	grpc.ServerStream
}

func (x *diathekePushAudioServer) Send(m *TranscriptionResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *diathekePushAudioServer) Recv() (*AudioTranscriptionRequest, error) {
	m := new(AudioTranscriptionRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Diatheke_PushText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushTextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).PushText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/PushText",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).PushText(ctx, req.(*PushTextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_CommandAndNotify_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DiathekeServer).CommandAndNotify(&diathekeCommandAndNotifyServer{stream})
}

type Diatheke_CommandAndNotifyServer interface {
	Send(*CommandToExecute) error
	Recv() (*CommandStatusUpdate, error)
	grpc.ServerStream
}

type diathekeCommandAndNotifyServer struct {
	grpc.ServerStream
}

func (x *diathekeCommandAndNotifyServer) Send(m *CommandToExecute) error {
	return x.ServerStream.SendMsg(m)
}

func (x *diathekeCommandAndNotifyServer) Recv() (*CommandStatusUpdate, error) {
	m := new(CommandStatusUpdate)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Diatheke_Say_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TTSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiathekeServer).Say(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.diatheke.Diatheke/Say",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiathekeServer).Say(ctx, req.(*TTSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diatheke_SayCallback_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SayCallbackRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiathekeServer).SayCallback(m, &diathekeSayCallbackServer{stream})
}

type Diatheke_SayCallbackServer interface {
	Send(*TTSResponse) error
	grpc.ServerStream
}

type diathekeSayCallbackServer struct {
	grpc.ServerStream
}

func (x *diathekeSayCallbackServer) Send(m *TTSResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Diatheke_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cobaltspeech.diatheke.Diatheke",
	HandlerType: (*DiathekeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Diatheke_Version_Handler,
		},
		{
			MethodName: "Models",
			Handler:    _Diatheke_Models_Handler,
		},
		{
			MethodName: "NewSession",
			Handler:    _Diatheke_NewSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _Diatheke_EndSession_Handler,
		},
		{
			MethodName: "PushText",
			Handler:    _Diatheke_PushText_Handler,
		},
		{
			MethodName: "Say",
			Handler:    _Diatheke_Say_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PushAudio",
			Handler:       _Diatheke_PushAudio_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CommandAndNotify",
			Handler:       _Diatheke_CommandAndNotify_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SayCallback",
			Handler:       _Diatheke_SayCallback_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "diatheke.proto",
}
